{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>WILDkCAT is a Python package that offers a comprehensive range of functions for extracting, retrieving and predicting enzyme kinetic data for a given metabolic model. The tool facilitates enzyme-constrained modelling by assigning specific kcat values to each combination of reaction, enzyme, and substrate(s).</p> <p>WILDkCAT integrates the BRENDA and SABIO-RK APIs to retrieve experimental values and CataPro to predict missing values. It can be used with various enzyme-constrained metabolic modelling methods, such as COBREXA.jl and GECKO, facilitating the seamless integration of kcat values into a given metabolic model.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#setup-a-python-environment","title":"Setup a Python environment","text":"<p>To ensure a clean and isolated setup, we recommend to use uv, a lightweight tool that simplifies Python environment and package management. If you don\u2019t have it yet:</p> macOS / LinuxWindows <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>Create and activate a virtual environment with uv:</p> macOS / LinuxWindows <pre><code>uv venv\nsource .venv/bin/activate\n</code></pre> <pre><code>uv venv\nsource .venv\\Scripts\\activate\n</code></pre> <p>Tip</p> <p>Using uv helps manage dependencies easily and keeps your environment clean, avoiding conflicts with other Python packages.</p>"},{"location":"installation/#install-wildkcat-from-pypi","title":"Install WILDkCAT from PyPI","text":"<p>Install WILDkCAT directly from PyPI:</p> <pre><code>uv pip install wildkcat \n</code></pre> <p>Verify the installation by checking the version:</p> <pre><code>wildkcat --version\n</code></pre>"},{"location":"installation/#environment-setup","title":"Environment Setup","text":"<p>Provide your BRENDA login credentials and Entrez API email adress to query the BRENDA enzyme database and NCBI database.</p> <p>Create a file named <code>.env</code> in the root of your project with the following content:</p> <pre><code>ENTREZ_EMAIL=your_email@example.com\nBRENDA_EMAIL=your_email@example.com\nBRENDA_PASSWORD=your_password\n</code></pre> <p>Note</p> <ul> <li>Replace the placeholders with the credentials from the BRENDA website account you created.</li> </ul> <p>Danger</p> <ul> <li>Keep the file <code>.env</code> private (e.g., add it to your <code>.gitignore</code>) as it contains sensitive information.</li> </ul>"},{"location":"installation/#install-catapro","title":"Install CataPro","text":"<p>CataPro is required for predicting kcat values using machine learning</p>"},{"location":"installation/#1-install-dependencies","title":"1. Install dependencies","text":"<pre><code>uv install pip install torch transformers numpy pandas RDKit\n</code></pre>"},{"location":"installation/#2-clone-the-catapro-repository","title":"2. Clone the CataPro repository","text":"<pre><code>git clone https://github.com/zchwang/CataPro\n</code></pre>"},{"location":"installation/#3-set-up-git-lfs","title":"3. Set up Git LFS","text":"<p>CataPro uses Git Large File Storage (LFS) to handle large model files.  If you don't have Git LFS installed, you can install it using the following command:</p> <pre><code>git lfs install\n</code></pre>"},{"location":"installation/#4-download-the-models","title":"4. Download the models","text":"<p>CataPro requires the models ProtT5 model and MolT5 model.</p> <p>Warning</p> <p>The models prot5_t5_xl_uniref50 and molt5-base-smiles2caption required for CataPro are 64 and 1.9 GB, respectively. </p> <pre><code>cd CataPro/models/\n\nGIT LFS_SKIP_SMUDGE=1 git clone https://huggingface.co/Rostlab/prot5_t5_xl_uniref50\ncd prot5_t5_xl_uniref50\ngit lfs pull\n\ncd ..\n\nGIT LFS_SKIP_SMUDGE=1 git clone https://huggingface.co/laituan245/molt5-base-smiles2caption\ncd molt5-base-smiles2caption\ngit lfs pull\n\ncd ../..\n</code></pre>"},{"location":"reference/","title":"Main functions","text":"<p>The WILDkCAT package is organized into modules: </p> <ol> <li> <p>Extraction : Extraction of kcat values from the provided model</p> </li> <li> <p>Retrieval : Retrieval of kcat values using curated databases (BRENDA and SABIO-RK)</p> </li> <li> <p>Prediction : Prediction of missing and low confidence kcat values using ML-based CataPro model</p> </li> <li> <p>Summary : Generates an HTML report summarizing the percentage and quality of kcat values identified for the model, along with their data sources.</p> </li> </ol>"},{"location":"reference/#extraction","title":"Extraction","text":""},{"location":"reference/#wildkcat.processing.extract_kcat.run_extraction","title":"<code>wildkcat.processing.extract_kcat.run_extraction(model_path, output_folder, report=True)</code>","text":"<p>Extracts kcat-related data from a metabolic model and generates output files and an optional HTML report.</p> <p>Parameters:</p> Name Type Description Default <code>model_path</code> <code>str</code> <p>Path to the metabolic model file (JSON, MATLAB, or SBML format).</p> required <code>output_folder</code> <code>str</code> <p>Path to the output folder where all the results will be saved.</p> required <code>report</code> <code>bool</code> <p>Whether to generate an HTML report (default: True).</p> <code>True</code> Source code in <code>wildkcat/processing/extract_kcat.py</code> <pre><code>def run_extraction(model_path: str, \n                   output_folder: str, \n                   report: bool = True) -&gt; None:\n    \"\"\"\n    Extracts kcat-related data from a metabolic model and generates output files and an optional HTML report.\n\n    Parameters:\n        model_path (str): Path to the metabolic model file (JSON, MATLAB, or SBML format).\n        output_folder (str): Path to the output folder where all the results will be saved.\n        report (bool, optional): Whether to generate an HTML report (default: True).\n    \"\"\"\n    # Intitialize logging\n    os.makedirs(\"logs\", exist_ok=True)\n    timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n    filename = f\"logs/extract_{timestamp}.log\"\n    logging.getLogger().addFilter(DedupFilter())\n    logging.basicConfig(filename=filename, encoding='utf-8', level=logging.INFO)\n\n    # Run extraction\n    model = read_model(model_path)\n    df, report_statistics = create_kcat_output(model)\n\n    # Save output\n    os.makedirs(output_folder, exist_ok=True)\n    output_path = os.path.join(output_folder, \"kcat.tsv\")\n    df.to_csv(output_path, sep='\\t', index=False)\n    logging.info(f\"Output saved to '{output_path}'\")\n    if report:\n        report_extraction(model, df, report_statistics, output_folder)\n</code></pre>"},{"location":"reference/#retrieval","title":"Retrieval","text":""},{"location":"reference/#wildkcat.processing.retrieve_kcat.run_retrieval","title":"<code>wildkcat.processing.retrieve_kcat.run_retrieval(output_folder, organism, temperature_range, pH_range, database='both', report=True)</code>","text":"<p>Retrieves closest kcat values from specified databases for entries in a kcat file, applies filtering criteria,  and saves the results to an output file.</p> <p>Parameters:</p> Name Type Description Default <code>output_folder</code> <code>str</code> <p>Path to the output folder where the results will be saved.</p> required <code>organism</code> <code>str</code> <p>Organism scientific name (e.g. \"Escherichia coli\", \"Homo sapiens\").</p> required <code>temperature_range</code> <code>tuple</code> <p>Acceptable temperature range for filtering (min, max).</p> required <code>pH_range</code> <code>tuple</code> <p>Acceptable pH range for filtering (min, max).</p> required <code>database</code> <code>str</code> <p>Specifies which database(s) to query for kcat values.  Options are 'both' (default), 'brenda', or 'sabio_rk'.</p> <code>'both'</code> <code>report</code> <code>bool</code> <p>Whether to generate an HTML report using the retrieved data (default: True).</p> <code>True</code> Source code in <code>wildkcat/processing/retrieve_kcat.py</code> <pre><code>def run_retrieval(output_folder: str,\n                  organism: str,\n                  temperature_range: tuple,\n                  pH_range: tuple,\n                  database: str = 'both',\n                  report: bool = True) -&gt; None:\n    \"\"\"\n    Retrieves closest kcat values from specified databases for entries in a kcat file, applies filtering criteria, \n    and saves the results to an output file.\n\n    Parameters:\n        output_folder (str): Path to the output folder where the results will be saved.\n        organism (str): Organism scientific name (e.g. \"Escherichia coli\", \"Homo sapiens\").\n        temperature_range (tuple): Acceptable temperature range for filtering (min, max).\n        pH_range (tuple): Acceptable pH range for filtering (min, max).\n        database (str, optional): Specifies which database(s) to query for kcat values. \n            Options are 'both' (default), 'brenda', or 'sabio_rk'.\n        report (bool, optional): Whether to generate an HTML report using the retrieved data (default: True).        \n    \"\"\"\n\n    # Load environment variables\n    load_dotenv()\n\n    # Intitialize logging\n    os.makedirs(\"logs\", exist_ok=True)\n    timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n    filename = f\"logs/retrieval_{timestamp}.log\"\n    logging.getLogger().addFilter(DedupFilter())\n    logging.basicConfig(filename=filename, encoding='utf-8', level=logging.INFO)\n\n\n    # Create a dict with the general criterias\n    general_criteria = {\n        \"Organism\": organism,\n        \"Temperature\": temperature_range,\n        \"pH\": pH_range\n    }\n\n    # Read the kcat file\n    if not os.path.exists(output_folder):\n        raise FileNotFoundError(f\"The specified output folder '{output_folder}' does not exist.\")\n\n    kcat_file_path = os.path.join(output_folder, \"kcat.tsv\")\n    if not os.path.isfile(kcat_file_path):\n        raise FileNotFoundError(f\"The specified file '{kcat_file_path}' does not exist in the output folder. Please run the function 'run_extraction()' first.\")\n\n    kcat_df = pd.read_csv(kcat_file_path, sep='\\t')\n\n    # Initialize new columns\n    kcat_df['kcat'] = None\n    kcat_df['matching_score'] = None\n\n    # Add data of the retrieve kcat values\n    kcat_df['kcat_substrate'] = None\n    kcat_df['kcat_organism'] = None\n    kcat_df['kcat_enzyme'] = None\n    kcat_df['kcat_temperature'] = None\n    kcat_df['kcat_ph'] = None\n    kcat_df['kcat_variant'] = None\n    kcat_df['kcat_db'] = None\n\n    # Retrieve kcat values from databases\n    request_count = 0\n    for row in tqdm(kcat_df.itertuples(), total=len(kcat_df), desc=\"Retrieving kcat values\"):\n        kcat_dict = row._asdict()\n\n        # Extract kcat and matching score\n        best_match, matching_score = extract_kcat(kcat_dict, general_criteria, database=database)\n        kcat_df.loc[row.Index, 'matching_score'] = matching_score\n\n        request_count += 1\n        if request_count % 300 == 0:\n            time.sleep(10)\n\n        if best_match is not None:\n            # Assign results to the main dataframe\n            kcat_df.loc[row.Index, 'kcat'] = best_match['adj_kcat']\n            kcat_df.loc[row.Index, 'kcat_substrate'] = best_match['Substrate']\n            kcat_df.loc[row.Index, 'kcat_organism'] = best_match['Organism']\n            kcat_df.loc[row.Index, 'kcat_enzyme'] = best_match['UniProtKB_AC']\n            kcat_df.loc[row.Index, 'kcat_temperature'] = best_match['adj_temp']\n            kcat_df.loc[row.Index, 'kcat_ph'] = best_match['pH']\n            kcat_df.loc[row.Index, 'kcat_variant'] = best_match['EnzymeVariant']\n            kcat_df.loc[row.Index, 'kcat_db'] = best_match['db']\n            if best_match.get('id_perc') != -1:\n                kcat_df.loc[row.Index, 'kcat_id_percent'] = best_match['id_perc']\n            if best_match.get('organism_score') != np.inf:\n                kcat_df.loc[row.Index, 'kcat_organism_score'] = best_match['organism_score']\n\n    # Select only one kcat value per reaction and substrate\n    kcat_df = merge_ec(kcat_df)\n\n    output_path = os.path.join(output_folder, \"kcat_retrieved.tsv\")\n    kcat_df.to_csv(output_path, sep='\\t', index=False)\n    logging.info(f\"Output saved to '{output_path}'\")\n\n    if report:\n        report_retrieval(kcat_df, output_folder)\n</code></pre>"},{"location":"reference/#prediction","title":"Prediction","text":""},{"location":"reference/#wildkcat.processing.predict_kcat.run_prediction_part1","title":"<code>wildkcat.processing.predict_kcat.run_prediction_part1(output_folder, limit_matching_score, report=True)</code>","text":"<p>Processes kcat data file to generate input files for CataPro prediction. Optionally, it can produce a summary report of the processed data.</p> <p>Parameters:</p> Name Type Description Default <code>output_folder</code> <code>str</code> <p>Path to the output folder where the results will be saved.</p> required <code>limit_matching_score</code> <code>int</code> <p>Threshold for filtering entries based on matching score.</p> required <code>report</code> <code>bool</code> <p>Whether to generate a report using the retrieved data (default: True).</p> <code>True</code> Source code in <code>wildkcat/processing/predict_kcat.py</code> <pre><code>def run_prediction_part1(output_folder: str,\n                         limit_matching_score: int, \n                         report: bool = True) -&gt; None:\n    \"\"\"\n    Processes kcat data file to generate input files for CataPro prediction.\n    Optionally, it can produce a summary report of the processed data.\n\n    Parameters:\n        output_folder (str): Path to the output folder where the results will be saved.\n        limit_matching_score (int): Threshold for filtering entries based on matching score.\n        report (bool, optional): Whether to generate a report using the retrieved data (default: True). \n    \"\"\"\n    # Intitialize logging\n    os.makedirs(\"logs\", exist_ok=True)\n    timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n    filename = f\"logs/prediction1_{timestamp}.log\"\n    logging.getLogger().addFilter(DedupFilter())\n    logging.basicConfig(filename=filename, encoding='utf-8', level=logging.INFO)\n\n    # Run prediction part 1\n    # Read the kcat file\n    if not os.path.exists(output_folder):\n        raise FileNotFoundError(f\"The specified output folder '{output_folder}' does not exist.\")\n\n    kcat_file_path = os.path.join(output_folder, \"kcat_retrieved.tsv\")\n    if not os.path.isfile(kcat_file_path):\n        raise FileNotFoundError(f\"The specified file '{kcat_file_path}' does not exist in the output folder. Please run the function 'run_retrieval()' first.\")\n\n    kcat_df = pd.read_csv(kcat_file_path, sep='\\t')\n\n    # Subset rows with no values or matching score above the limit\n    kcat_df = kcat_df[(kcat_df['matching_score'] &gt;= limit_matching_score) | (kcat_df['matching_score'].isnull())]\n    # Drop rows with no UniProt ID or no substrates_kegg\n    before_duplicates_filter = len(kcat_df) - 1 \n    kcat_df = kcat_df[kcat_df['uniprot'].notnull() &amp; kcat_df['substrates_kegg'].notnull()]\n    nb_missing_enzymes = before_duplicates_filter - len(kcat_df) + 1 \n\n    # Generate CataPro input file\n    catapro_input_df, substrates_to_smiles_df, report_statistics = create_catapro_input_file(kcat_df)\n\n    # Save the CataPro input file and substrates to SMILES mapping\n    os.makedirs(os.path.join(output_folder, \"machine_learning\"), exist_ok=True)\n    output_path = os.path.join(output_folder, \"machine_learning/catapro_input.csv\")\n    kcat_df.to_csv(output_path, sep='\\t', index=False)\n    catapro_input_df.to_csv(output_path, sep=',', index=True)\n    substrates_to_smiles_df.to_csv(output_path.replace('.csv', '_substrates_to_smiles.tsv'), sep='\\t', index=False)\n    logging.info(f\"Output saved to '{output_path}'\")\n\n    # Add statistics \n    report_statistics[\"missing_enzymes\"] = nb_missing_enzymes\n\n    if report:\n        report_prediction_input(catapro_input_df, report_statistics, output_folder)\n</code></pre>"},{"location":"reference/#wildkcat.processing.predict_kcat.run_prediction_part2","title":"<code>wildkcat.processing.predict_kcat.run_prediction_part2(output_folder, catapro_predictions_path, limit_matching_score)</code>","text":"<p>Runs the second part of the kcat prediction pipeline by integrating Catapro predictions, mapping substrates to SMILES, formatting the output, and optionally generating a report.</p> <p>Parameters:</p> Name Type Description Default <code>output_folder</code> <code>str</code> <p>Path to the output folder where the results will be saved.</p> required <code>catapro_predictions_path</code> <code>str</code> <p>Path to the CataPro predictions CSV file.</p> required <code>limit_matching_score</code> <code>float</code> <p>Threshold for taking predictions over retrieved values.</p> required Source code in <code>wildkcat/processing/predict_kcat.py</code> <pre><code>def run_prediction_part2(output_folder: str,\n                         catapro_predictions_path: str,\n                         limit_matching_score: int) -&gt; None:\n    \"\"\"\n    Runs the second part of the kcat prediction pipeline by integrating Catapro predictions,\n    mapping substrates to SMILES, formatting the output, and optionally generating a report.\n\n    Parameters:\n        output_folder (str): Path to the output folder where the results will be saved.\n        catapro_predictions_path (str): Path to the CataPro predictions CSV file.\n        limit_matching_score (float): Threshold for taking predictions over retrieved values.\n    \"\"\" \n    # Intitialize logging\n    os.makedirs(\"logs\", exist_ok=True)\n    timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n    filename = f\"logs/prediction2_{timestamp}.log\"\n    logging.getLogger().addFilter(DedupFilter())\n    logging.basicConfig(filename=filename, encoding='utf-8', level=logging.INFO)\n\n    # Run prediction part 2\n    # Read the kcat file\n    if not os.path.exists(output_folder):\n        raise FileNotFoundError(f\"The specified output folder '{output_folder}' does not exist.\")\n    kcat_file_path = os.path.join(output_folder, \"kcat_retrieved.tsv\")\n    if not os.path.isfile(kcat_file_path):\n        raise FileNotFoundError(f\"The specified file '{kcat_file_path}' does not exist in the output folder. Please run the function 'run_extraction()' first.\")\n    kcat_df = pd.read_csv(kcat_file_path, sep='\\t')\n    substrates_to_smiles_path = os.path.join(output_folder, \"machine_learning/catapro_input_substrates_to_smiles.tsv\")\n    substrates_to_smiles = pd.read_csv(substrates_to_smiles_path, sep='\\t')\n    catapro_predictions_df = pd.read_csv(catapro_predictions_path, sep=',')\n    kcat_df = integrate_catapro_predictions(kcat_df, \n                                            substrates_to_smiles,\n                                            catapro_predictions_df\n                                            )\n\n    # Save the output as a TSV file\n    kcat_df = format_output(kcat_df, limit_matching_score)\n    output_path = os.path.join(output_folder, \"kcat_full.tsv\")\n    kcat_df.to_csv(output_path, sep='\\t', index=False)\n    logging.info(f\"Output saved to '{output_path}'\")\n</code></pre>"},{"location":"reference/#summary-report","title":"Summary report","text":""},{"location":"reference/#wildkcat.processing.summary.generate_summary_report","title":"<code>wildkcat.processing.summary.generate_summary_report(model_path, output_folder)</code>","text":"<p>Generate a HTML report summarizing the kcat extraction, retrieval and prediction for a given model. </p> <p>Parameters:</p> Name Type Description Default <code>model_path</code> <code>str</code> <p>Path to the metabolic model file (JSON, MATLAB, or SBML format).</p> required <code>output_folder</code> <code>str</code> <p>Path to the output folder where the kcat file is located.</p> required Source code in <code>wildkcat/processing/summary.py</code> <pre><code>def generate_summary_report(model_path: str,\n                            output_folder: str) -&gt; None:\n    \"\"\"\n    Generate a HTML report summarizing the kcat extraction, retrieval and prediction for a given model. \n\n    Parameters:\n        model_path (str): Path to the metabolic model file (JSON, MATLAB, or SBML format).\n        output_folder (str): Path to the output folder where the kcat file is located.\n    \"\"\"\n    # Read the kcat file\n    if not os.path.exists(output_folder):\n        raise FileNotFoundError(f\"The specified output folder '{output_folder}' does not exist.\")\n\n    kcat_file_path = os.path.join(output_folder, \"kcat_full.tsv\")\n    if not os.path.isfile(kcat_file_path):\n        raise FileNotFoundError(f\"The specified file '{kcat_file_path}' does not exist in the output folder. Please run the full pipeline.\")\n    kcat_df = pd.read_csv(kcat_file_path, sep='\\t')\n    model = read_model(model_path)\n    report_final(model, kcat_df, output_folder)\n</code></pre>"},{"location":"reference/#matching-process-and-scoring","title":"Matching process and scoring","text":"<p>The matching process is designed to select the most appropriate kcat value when multiple candidates are available. Each candidate is first assigned a score based on several criteria, such as:  </p> <ul> <li>kcat specific criteria:<ul> <li>Substrate</li> <li>Catalytic enzyme(s)</li> </ul> </li> <li>General criteria:<ul> <li>Organism</li> <li>Temperature</li> <li>pH</li> </ul> </li> </ul> <p>If two or more candidates receive the same score, tie-breaking rules are applied in the following order:  </p> <ol> <li>Enzyme sequence identity \u2013 the value associated with the most similar protein sequence is preferred.  </li> <li>Organism proximity \u2013 preference is given to kcat values measured in organisms closest to the target species.  </li> <li>Minimal kcat value \u2013 if ambiguity remains, the smallest kcat value is chosen. </li> </ol>"},{"location":"reference/#wildkcat.utils.matching","title":"<code>wildkcat.utils.matching</code>","text":""},{"location":"reference/#wildkcat.utils.matching.check_catalytic_enzyme","title":"<code>check_catalytic_enzyme(candidate, kcat_dict)</code>","text":"<p>Checks whether the enzyme in a candidate entry matches the model's enzyme. Identifies the catalytic enzyme using UniProt API.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def check_catalytic_enzyme(candidate, kcat_dict): \n    \"\"\"\n    Checks whether the enzyme in a candidate entry matches the model's enzyme.\n    Identifies the catalytic enzyme using UniProt API.\n    \"\"\"\n    if pd.notna(kcat_dict['catalytic_enzyme']):\n        catalytic_enzymes = str(kcat_dict['catalytic_enzyme']).split(\";\")\n        if candidate[\"UniProtKB_AC\"] in catalytic_enzymes:\n            return 0\n    return 2\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.check_organism","title":"<code>check_organism(candidate, general_criteria)</code>","text":"<p>Checks whether the organism in a candidate entry matches the expected organism.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def check_organism(candidate, general_criteria): \n    \"\"\"\n    Checks whether the organism in a candidate entry matches the expected organism.\n    \"\"\"\n    if candidate[\"Organism\"] == general_criteria[\"Organism\"]:\n        return 0\n    return 2\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.check_pH","title":"<code>check_pH(candidate, general_criteria)</code>","text":"<p>Checks whether the pH in a candidate entry matches the expected pH.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def check_pH(candidate, general_criteria):\n    \"\"\"\n    Checks whether the pH in a candidate entry matches the expected pH.\n    \"\"\"\n    ph_min, ph_max = general_criteria[\"pH\"]\n    candidate_ph = candidate.get(\"pH\", None)\n    if ph_min &lt;= candidate_ph &lt;= ph_max:\n        return 0\n    elif pd.isna(candidate_ph):\n        return 1\n    else:  # Out of range\n        return 2\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.check_substrate","title":"<code>check_substrate(entry, kcat_dict=None, candidate=None)</code>","text":"<p>Checks whether the substrate in a candidate entry matches the model's substrates.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def check_substrate(entry, kcat_dict=None, candidate=None):\n    \"\"\"\n    Checks whether the substrate in a candidate entry matches the model's substrates.\n    \"\"\"\n    api = entry.get(\"db\", candidate.get(\"db\") if candidate else None)\n\n    # Normalisation des champs\n    entry_subs = entry.get(\"Substrate\", \"\")\n    entry_prods = entry.get(\"Product\", \"\")\n    entry_kegg = entry.get(\"KeggReactionID\")\n\n    cand_subs = candidate.get(\"Substrate\", \"\") if candidate else \"\"\n    cand_prods = candidate.get(\"Product\", \"\") if candidate else \"\"\n    cand_kegg = candidate.get(\"KeggReactionID\") if candidate else \"\"\n\n    model_subs = (kcat_dict or {}).get(\"substrates_name\", \"\")\n    model_prods = (kcat_dict or {}).get(\"products_name\", \"\")\n    model_kegg = (kcat_dict or {}).get(\"rxn_kegg\")\n\n    # --- logique identique \u00e0 avant ---\n    if api == \"sabio_rk\":\n\n        entry_kegg = None if pd.isna(entry_kegg) else entry_kegg\n        model_kegg = None if pd.isna(model_kegg) else model_kegg\n        cand_kegg  = None if pd.isna(cand_kegg) else cand_kegg\n\n        if model_kegg and entry_kegg and _norm_name(model_kegg) == _norm_name(entry_kegg):\n            if _any_intersection(entry_subs, model_subs) or _any_intersection(entry_prods, model_prods):\n                return 0\n        if cand_kegg and entry_kegg and _norm_name(cand_kegg) == _norm_name(entry_kegg):\n            if _any_intersection(entry_subs, cand_subs) or _any_intersection(entry_prods, cand_prods):\n                return 0\n        base_subs = model_subs or cand_subs\n        if _any_intersection(entry_subs, base_subs):\n            return 0\n        return 3\n\n    elif api == \"brenda\":\n        base_subs = model_subs or cand_subs\n        if _any_intersection(entry_subs, base_subs):\n            return 0\n        return 3\n\n    return 3\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.check_temperature","title":"<code>check_temperature(candidate, general_criteria, api_output, min_r2=0.8, expected_range=(50000, 150000))</code>","text":"<p>Checks whether the temperature in a candidate entry matches the expected temperature. If the temperature is within the specified range is not met, verify if the Arrhenius equation can be applied.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def check_temperature(candidate, general_criteria, api_output, min_r2=0.8, expected_range=(50000, 150000)): \n    \"\"\"\n    Checks whether the temperature in a candidate entry matches the expected temperature.\n    If the temperature is within the specified range is not met, verify if the Arrhenius equation can be applied.\n    \"\"\"\n\n    temp_min, temp_max = general_criteria[\"Temperature\"]\n    candidate_temp = candidate.get(\"Temperature\")\n\n    if temp_min &lt;= candidate_temp &lt;= temp_max:\n        return 0, False\n\n    # Try to find a correct the kcat value using the Arrhenius equation\n    ph_min, ph_max = general_criteria[\"pH\"]\n\n    # Base filters\n    filters = (\n        api_output[\"pH\"].between(ph_min, ph_max)\n        &amp; (api_output[\"UniProtKB_AC\"] == candidate[\"UniProtKB_AC\"])\n        &amp; api_output[\"Temperature\"].notna()\n        &amp; api_output[\"value\"].notna()\n    )\n\n    valid_idx = api_output.apply(\n        lambda row: check_substrate(row.to_dict(), None, candidate) == 0,\n        axis=1\n        )\n\n    filters = filters &amp; valid_idx\n\n    temps_dispo = api_output.loc[filters, \"Temperature\"].nunique()\n    api_filtered = api_output.loc[filters, [\"Temperature\", \"value\"]].copy()\n\n    # Convert temperatures to Kelvin\n    api_filtered[\"Temperature\"] = api_filtered[\"Temperature\"] + 273.15\n\n    if temps_dispo &gt;= 2:\n        ea, r2 = calculate_ea(api_filtered)\n        if r2 &gt;= min_r2 and ea &gt; 0:\n            if not (expected_range[0] &lt;= ea &lt;= expected_range[1]):\n                logging.warning(f\"{candidate.get('ECNumber')}: Estimated Ea ({ea:.0f} J/mol) is outside the expected range {expected_range} J/mol.\")\n            # Go Arrhenius\n            return 0, True\n\n    if pd.isna(candidate_temp):\n        return 1, False\n\n    else:\n        return 2, False\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.check_variant","title":"<code>check_variant(candidate)</code>","text":"<p>Checks whether the enzyme variant in a candidate entry is wildtype or unknown.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def check_variant(candidate):\n    \"\"\"\n    Checks whether the enzyme variant in a candidate entry is wildtype or unknown.\n    \"\"\"\n    if candidate[\"EnzymeVariant\"] == \"wildtype\":\n        return 0\n    else:  # Unknown\n        return 1\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.compute_score","title":"<code>compute_score(kcat_dict, candidate, general_criteria, api_output)</code>","text":"<p>Compute a score for the candidate based on the Kcat dictionary and general criteria.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def compute_score(kcat_dict, candidate, general_criteria, api_output):\n    \"\"\"\n    Compute a score for the candidate based on the Kcat dictionary and general criteria.\n    \"\"\"\n    score = 0\n    # Check catalytic enzyme\n    score += check_catalytic_enzyme(candidate, kcat_dict)\n    # Check organism\n    if score != 0: \n        score += check_organism(candidate, general_criteria)\n    # Check variant\n    score += check_variant(candidate) \n    # Check pH\n    score += check_pH(candidate, general_criteria)\n    # Check substrate \n    score += check_substrate(candidate, kcat_dict)\n    # Check temperature \n    temperature_penalty, arrhenius = check_temperature(candidate, general_criteria, api_output) \n    score += temperature_penalty\n    return score, arrhenius\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.find_best_match","title":"<code>find_best_match(kcat_dict, api_output, general_criteria)</code>","text":"Finds the best matching enzyme entry from the provided API output based on <ul> <li>Kcat specific criteria: <ul> <li>Substrate </li> <li>Catalytic enzyme(s)</li> </ul> </li> <li>General criteria : <ul> <li>Organism</li> <li>Temperature</li> <li>pH</li> </ul> </li> </ul> <p>This function filters out mutant enzyme variants, orders the remaining entries based on enzyme and organism similarity, and iteratively computes a score for each candidate to identify the best match. If a candidate requires an Arrhenius adjustment, the kcat value is recalculated accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>kcat_dict</code> <code>dict</code> <p>Dictionary containing enzyme information.</p> required <code>api_output</code> <code>DataFrame</code> <p>DataFrame containing kcat entries and metadata from an API.</p> required <code>general_criteria</code> <code>dict</code> <p>Dictionary specifying matching criteria.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[float, Optional[Dict[str, Any]]]</code> <p>best_score (float): The lowest score found, representing the best match. best_candidate (dict or None): Dictionary of the best matching candidate's data, or None if no match is found.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def find_best_match(kcat_dict, api_output, general_criteria) -&gt; Tuple[float, Optional[Dict[str, Any]]]:\n    \"\"\"\n    Finds the best matching enzyme entry from the provided API output based on: \n        - Kcat specific criteria: \n            * Substrate \n            * Catalytic enzyme(s)\n        - General criteria : \n            * Organism\n            * Temperature\n            * pH\n\n    This function filters out mutant enzyme variants, orders the remaining entries based on enzyme and organism similarity,\n    and iteratively computes a score for each candidate to identify the best match. If a candidate requires an Arrhenius\n    adjustment, the kcat value is recalculated accordingly.\n\n    Parameters:\n        kcat_dict (dict): Dictionary containing enzyme information.\n        api_output (pd.DataFrame): DataFrame containing kcat entries and metadata from an API.\n        general_criteria (dict): Dictionary specifying matching criteria.\n\n    Returns:\n        tuple:\n            best_score (float): The lowest score found, representing the best match.\n            best_candidate (dict or None): Dictionary of the best matching candidate's data, or None if no match is found.\n    \"\"\"\n\n    # 1. Remove mutant enzymes\n    api_output = api_output[api_output[\"EnzymeVariant\"].isin(['wildtype', None])]\n    if api_output.empty:\n        return 14, None\n\n    # 2. Compute score and adjust kcat if needed\n    scores = []\n    adjusted_kcats, adjusted_temps = [], []\n\n    for _, row in api_output.iterrows():\n        candidate_dict = row.to_dict()\n        score, arrhenius = compute_score(kcat_dict, candidate_dict, general_criteria, api_output)\n        if arrhenius:\n            kcat = arrhenius_equation(candidate_dict, api_output, general_criteria)\n            candidate_dict['value'] = kcat\n            candidate_dict['Temperature'] = np.mean(general_criteria[\"Temperature\"])\n        scores.append(score)\n        adjusted_kcats.append(candidate_dict.get('value', row['value']))\n        adjusted_temps.append(candidate_dict.get('Temperature', row['Temperature']))\n\n    api_output = api_output.copy()\n    api_output['score'] = scores\n    api_output['adj_kcat'] = adjusted_kcats\n    api_output['adj_temp'] = adjusted_temps\n\n    api_output[\"score\"] = pd.to_numeric(api_output[\"score\"], errors=\"coerce\").fillna(13)\n    api_output[\"adj_kcat\"] = pd.to_numeric(api_output[\"adj_kcat\"], errors=\"coerce\")\n\n    # Initialize columns for tie-breaking\n    api_output['id_perc'] = -1\n    api_output['organism_score'] = np.inf\n\n    # 3. Keep only best-score candidates\n    min_score = api_output['score'].min()\n    tied = api_output[api_output['score'] == min_score]\n\n    # 4. Tie-breaking\n    if len(tied) &gt; 1:\n        # Tie-break with enzyme identity\n        tied = closest_enz(kcat_dict, tied)\n        if not tied['id_perc'].isna().all():\n            max_id = tied['id_perc'].max()\n            tied = tied[tied['id_perc'] == max_id]\n\n    if len(tied) &gt; 1:\n        # Tie-break with taxonomy\n        tied = closest_taxonomy(general_criteria, tied)\n        if not tied['organism_score'].isna().all():\n            min_tax = tied['organism_score'].min()\n            tied = tied[tied['organism_score'] == min_tax]\n\n    if len(tied) &gt; 1:\n        # Tie-break with max kcat value\n        max_kcat = tied['adj_kcat'].max()\n        tied = tied[tied['adj_kcat'] == max_kcat]\n\n    # 5. Select best candidate\n    best_candidate = tied.iloc[0].to_dict()\n    best_candidate['catalytic_enzyme'] = kcat_dict.get('catalytic_enzyme')\n    best_score = best_candidate['score']\n\n    return best_score, best_candidate\n</code></pre>"},{"location":"reference/#find-closest-enzyme-and-organism","title":"Find closest enzyme and organism","text":""},{"location":"reference/#wildkcat.utils.organism","title":"<code>wildkcat.utils.organism</code>","text":""},{"location":"reference/#wildkcat.utils.organism.closest_enz","title":"<code>closest_enz(kcat_dict, api_output)</code>","text":"<p>Retrieve and ranks the enzymes sequences closest to the sequence of the target enzyme based on the percentage of identity. If the reference UniProt ID is missing, invalid, or the sequence cannot be retrieved, the function returns the input DataFrame with \"id_perc\" set to None.</p> <p>Parameters:</p> Name Type Description Default <code>kcat_dict</code> <code>dict</code> <p>Dictionary containing at least the key 'uniprot_model' with the reference UniProt ID.</p> required <code>api_output</code> <code>DataFrame</code> <p>DataFrame containing a column \"UniProtKB_AC\" with UniProt IDs to compare against.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A copy of <code>api_output</code> with an added \"id_perc\" column (identity percentage).</p> Source code in <code>wildkcat/utils/organism.py</code> <pre><code>def closest_enz(kcat_dict, api_output) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieve and ranks the enzymes sequences closest to the sequence of the target enzyme based on the percentage of identity.\n    If the reference UniProt ID is missing, invalid, or the sequence cannot be retrieved, the function returns the input DataFrame with \"id_perc\" set to None.\n\n    Parameters:    \n        kcat_dict (dict): Dictionary containing at least the key 'uniprot_model' with the reference UniProt ID.\n        api_output (pd.DataFrame): DataFrame containing a column \"UniProtKB_AC\" with UniProt IDs to compare against.\n\n    Returns:\n        pd.DataFrame: A copy of `api_output` with an added \"id_perc\" column (identity percentage). \n    \"\"\"\n\n    def _calculate_identity(seq_ref, seq_db):\n        \"\"\"\n        Returns the percentage of identical characters between two sequences.\n        Adapted from https://gist.github.com/JoaoRodrigues/8c2f7d2fc5ae38fc9cb2 \n\n        Parameters: \n            seq_ref (str): The reference sequence.\n            seq_db (str): The sequence to compare against.\n\n        Returns: \n            float: The percentage of identical characters between the two sequences.\n        \"\"\"\n        matches = [a == b for a, b in zip(seq_ref, seq_db)]\n        return (100 * sum(matches)) / len(seq_ref)\n\n    ref_uniprot_id = kcat_dict.get('catalytic_enzyme')\n    if pd.isna(ref_uniprot_id) or (\";\" in str(ref_uniprot_id)):\n        api_output = api_output.copy()\n        api_output[\"id_perc\"] = None\n        return api_output\n\n    ref_seq = convert_uniprot_to_sequence(ref_uniprot_id)\n    if ref_seq is None:\n        api_output = api_output.copy()\n        api_output[\"id_perc\"] = None\n        return api_output\n\n    aligner = Align.PairwiseAligner()\n    identity_scores = []\n\n    for uniprot_id in api_output[\"UniProtKB_AC\"]:\n        if pd.isna(uniprot_id):\n            identity_scores.append(None)\n            continue\n        seq = convert_uniprot_to_sequence(uniprot_id)\n        if seq is None:\n            identity_scores.append(None)\n            continue\n        elif len(seq) == 0:\n            identity_scores.append(0)\n            continue\n\n        alignments = aligner.align(ref_seq, seq)\n        aligned_ref, aligned_db = alignments[0]\n        id_score = _calculate_identity(aligned_ref, aligned_db)\n        identity_scores.append(id_score)\n\n    api_output = api_output.copy()\n    api_output[\"id_perc\"] = identity_scores\n\n    return api_output\n</code></pre>"},{"location":"reference/#wildkcat.utils.organism.closest_taxonomy","title":"<code>closest_taxonomy(general_criteria, api_output)</code>","text":"<p>Retrieve and ranks the organisms based on their taxonomic similarity to the reference organism.</p> <p>Parameters:</p> Name Type Description Default <code>general_criteria</code> <code>dict</code> <p>Dictionary containing at least the key 'organism' with the reference organism.</p> required <code>api_output</code> <code>DataFrame</code> <p>DataFrame containing a column \"Organism\". </p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A copy of <code>api_output</code> with an added \"organism_score\" column.</p> Source code in <code>wildkcat/utils/organism.py</code> <pre><code>def closest_taxonomy(general_criteria, api_output) -&gt; pd.DataFrame: \n    \"\"\"\n    Retrieve and ranks the organisms based on their taxonomic similarity to the reference organism.\n\n    Parameters:    \n        general_criteria (dict): Dictionary containing at least the key 'organism' with the reference organism.\n        api_output (pd.DataFrame): DataFrame containing a column \"Organism\". \n\n    Returns:\n        pd.DataFrame: A copy of `api_output` with an added \"organism_score\" column.\n    \"\"\"\n    @lru_cache(maxsize=None)\n    def _fetch_taxonomy(species_name): \n        \"\"\"\n        Fetches the taxonomic lineage for a given species name using NCBI Entrez.\n\n        Parameters:\n            species_name (str): The name of the species.\n\n        Returns: \n            list: A list of scientific names representing the taxonomic lineage.\n        \"\"\"\n        Entrez.email = os.getenv(\"ENTREZ_EMAIL\")\n        handle = Entrez.esearch(db=\"taxonomy\", term=species_name)\n        record = Entrez.read(handle)\n        if not record[\"IdList\"]:\n            return []\n        tax_id = record[\"IdList\"][0]\n\n        handle = Entrez.efetch(db=\"taxonomy\", id=tax_id, retmode=\"xml\")\n        records = Entrez.read(handle)\n        if not records:\n            return []\n\n        lineage = [taxon[\"ScientificName\"] for taxon in records[0][\"LineageEx\"]]\n        lineage.append(records[0][\"ScientificName\"])  # include the species itself\n        return lineage\n\n    @lru_cache(maxsize=None)\n    def _calculate_taxonomy_score(ref_organism, target_organism): \n        \"\"\"\n        Calculate a taxonomy distance score between reference and target organisms.\n\n        Parameters: \n            ref_organism (str): The reference organism's name.\n            target_organism (str): The target organism's name.\n\n        Returns:\n            int: distance between reference and target organisms (0 = identical species, higher = more distant).\n        \"\"\"\n        ref_lineage = _fetch_taxonomy(ref_organism)\n        target_lineage = _fetch_taxonomy(target_organism)\n\n        if not target_lineage: # If target organism is not found\n            return len(ref_lineage) + 1  # Penalize missing taxonomy\n\n        similarity = 0\n\n        for taxon in target_lineage: \n            if taxon in ref_lineage:\n                similarity += 1\n            else:\n                break\n        return len(ref_lineage) - similarity\n\n\n    ref_organism = general_criteria['Organism']\n    api_output = api_output.copy()\n    api_output[\"organism_score\"] = [\n        _calculate_taxonomy_score(ref_organism, target) \n        for target in api_output[\"Organism\"]\n    ]\n    return api_output\n</code></pre>"},{"location":"reference/#correct-the-kcat-value-using-arrhenius-equation","title":"Correct the kcat value using Arrhenius equation","text":""},{"location":"reference/#wildkcat.utils.temperature","title":"<code>wildkcat.utils.temperature</code>","text":""},{"location":"reference/#wildkcat.utils.temperature.arrhenius_equation","title":"<code>arrhenius_equation(candidate, api_output, general_criteria)</code>","text":"<p>Estimates the kcat value at a target temperature using the Arrhenius equation, based on available experimental data.</p> <p>Parameters:</p> Name Type Description Default <code>candidate</code> <code>dict</code> <p>Information about the enzyme candidate.</p> required <code>api_output</code> <code>DataFrame</code> <p>DataFrame containing experimental kcat values.</p> required <code>general_criteria</code> <code>dict</code> <p>Dictionary specifying selection criteria, including 'Temperature' and 'pH'.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Estimated kcat value at the objective temperature, calculated using the Arrhenius equation.</p> Source code in <code>wildkcat/utils/temperature.py</code> <pre><code>def arrhenius_equation(candidate, api_output, general_criteria) -&gt; float:\n    \"\"\"\n    Estimates the kcat value at a target temperature using the Arrhenius equation, based on available experimental data.\n\n    Parameters:\n        candidate (dict): Information about the enzyme candidate.\n        api_output (pd.DataFrame): DataFrame containing experimental kcat values.\n        general_criteria (dict): Dictionary specifying selection criteria, including 'Temperature' and 'pH'.\n\n    Returns:\n        float: Estimated kcat value at the objective temperature, calculated using the Arrhenius equation.\n    \"\"\"\n\n    def calculate_kcat(temp_obj, ea, kcat_ref, temp_ref): \n        \"\"\"\n        Calculates the catalytic rate constant (kcat) at a given temperature using the Arrhenius equation.\n\n        Parameters: \n            temp_obj (float): The target temperature (in Kelvin) at which to calculate kcat.\n            ea (float): The activation energy calculated using find_ea(). \n            kcat_ref (float): The reference kcat value measured at temp_ref.\n            temp_ref (float): The reference temperature (in Kelvin) at which kcat_ref was measured.\n\n        Returns: \n            float: The calculated kcat value at temp_obj.\n        \"\"\"\n        r = 8.314\n        kcat_obj = kcat_ref * np.exp(ea / r * (1/temp_ref - 1/temp_obj))\n        return kcat_obj\n\n    # Objective temperature\n    obj_temp = np.mean(general_criteria[\"Temperature\"]) + 273.15\n\n    # Format the api_output DataFrame\n    ph_min, ph_max = general_criteria[\"pH\"]\n    filters = (\n        (api_output[\"UniProtKB_AC\"] == candidate[\"UniProtKB_AC\"]) &amp;\n        api_output[\"Temperature\"].notna() &amp;\n        api_output[\"value\"].notna() &amp;\n        api_output[\"pH\"].between(ph_min, ph_max)\n    )\n    api_filtered = api_output.loc[filters, [\"Temperature\", \"value\"]].copy()\n\n    # Convert temperatures to Kelvin\n    api_filtered[\"Temperature\"] = api_filtered[\"Temperature\"] + 273.15\n\n    # Estimate the activation energy (Ea)\n    ea, _ = calculate_ea(api_filtered)\n\n    # Select one kcat for the ref\n    kcat_ref = float(api_filtered['value'].iloc[0])\n    temp_ref = float(api_filtered['Temperature'].iloc[0])\n\n    kcat = calculate_kcat(obj_temp, ea, kcat_ref, temp_ref)\n    return kcat\n</code></pre>"},{"location":"reference/#wildkcat.utils.temperature.calculate_ea","title":"<code>calculate_ea(df)</code>","text":"<p>Estimate the activation energy (Ea) using the Arrhenius equation from kcat values at different temperatures.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame with at least 'Temperature' (\u00b0C) and 'value' (kcat) columns.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Estimated activation energy (Ea) in J/mol.</p> Source code in <code>wildkcat/utils/temperature.py</code> <pre><code>def calculate_ea(df) -&gt; float:\n    \"\"\"\n    Estimate the activation energy (Ea) using the Arrhenius equation from kcat values at different temperatures.\n\n    Parameters:\n        df (pd.DataFrame): DataFrame with at least 'Temperature' (\u00b0C) and 'value' (kcat) columns.\n\n    Returns:\n        float: Estimated activation energy (Ea) in J/mol. \n    \"\"\"\n\n    r = 8.314  # Gas constant in J/(mol*K)\n\n    # Filter out rows with missing values\n    valid = df[['Temperature', 'value']].dropna()\n\n    temps_K = valid['Temperature'].values\n    kcats = pd.to_numeric(valid['value'], errors='coerce').values\n\n    x = 1 / temps_K\n    y = np.log(kcats)\n    slope, intercept = np.polyfit(x, y, 1)\n\n    # R2 \n    y_pred = slope * x + intercept\n    ss_res = np.sum((y - y_pred) ** 2)\n    ss_tot = np.sum((y - np.mean(y)) ** 2)\n    r2 = 1 - ss_res / ss_tot if ss_tot != 0 else np.nan\n\n    # Activation energy \n    ea = float(-slope * r)\n\n    return ea, r2 \n</code></pre>"},{"location":"reference/#api","title":"API","text":""},{"location":"reference/#wildkcat.api.brenda_api","title":"<code>wildkcat.api.brenda_api</code>","text":""},{"location":"reference/#wildkcat.api.brenda_api.create_brenda_client","title":"<code>create_brenda_client(wsdl_url='https://www.brenda-enzymes.org/soap/brenda_zeep.wsdl')</code>","text":"<p>Creates and configures a persistent SOAP client for the BRENDA API.</p> <p>Parameters:</p> Name Type Description Default <code>wsdl_url</code> <code>str</code> <p>URL to the BRENDA WSDL file.</p> <code>'https://www.brenda-enzymes.org/soap/brenda_zeep.wsdl'</code> <p>Returns:</p> Type Description <code>Client</code> <p>zeep.Client: Configured SOAP client.</p> Source code in <code>wildkcat/api/brenda_api.py</code> <pre><code>def create_brenda_client(wsdl_url: str = \"https://www.brenda-enzymes.org/soap/brenda_zeep.wsdl\") -&gt; Client:\n    \"\"\"\n    Creates and configures a persistent SOAP client for the BRENDA API.\n\n    Parameters:\n        wsdl_url (str): URL to the BRENDA WSDL file.\n\n    Returns:\n        zeep.Client: Configured SOAP client.\n    \"\"\"\n    # Configure retry logic for network resilience\n    session = Session()\n    retry = Retry(total=3, backoff_factor=0.5, status_forcelist=[500, 502, 503, 504])\n    adapter = HTTPAdapter(max_retries=retry)\n    session.mount(\"http://\", adapter)\n    session.mount(\"https://\", adapter)\n\n    # Set a custom User-Agent (some servers block default Python UA)\n    session.headers.update({\"User-Agent\": \"BRENDA-Client\"})\n\n    # Create zeep transport and settings\n    transport = Transport(session=session, cache=InMemoryCache())\n    settings = Settings(strict=False, xml_huge_tree=True) \n\n    return Client(wsdl_url, settings=settings, transport=transport)\n</code></pre>"},{"location":"reference/#wildkcat.api.brenda_api.get_brenda_credentials","title":"<code>get_brenda_credentials()</code>","text":"<p>Retrieves and hashes BRENDA API credentials from environment variables.</p> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>tuple[str, str]: (email, hashed_password)</p> Source code in <code>wildkcat/api/brenda_api.py</code> <pre><code>def get_brenda_credentials() -&gt; tuple[str, str]:\n    \"\"\"\n    Retrieves and hashes BRENDA API credentials from environment variables.\n\n    Returns:\n        tuple[str, str]: (email, hashed_password)\n    \"\"\"\n    email = os.getenv(\"BRENDA_EMAIL\")\n    password = os.getenv(\"BRENDA_PASSWORD\")\n\n    if not email or not password:\n        raise ValueError(\"BRENDA_EMAIL and BRENDA_PASSWORD environment variables must be set.\")\n\n    hashed_password = hashlib.sha256(password.encode(\"utf-8\")).hexdigest()\n    return email, hashed_password\n</code></pre>"},{"location":"reference/#wildkcat.api.brenda_api.get_cofactor","title":"<code>get_cofactor(ec_number)</code>  <code>cached</code>","text":"<p>Queries the BRENDA SOAP API to retrieve cofactor information for a given Enzyme Commission (EC) number.</p> <p>Parameters:</p> Name Type Description Default <code>ec_number</code> <code>str</code> <p>EC number (e.g., '1.1.1.1').</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing turnover number entries.</p> Source code in <code>wildkcat/api/brenda_api.py</code> <pre><code>@lru_cache(maxsize=None)\ndef get_cofactor(ec_number) -&gt; pd.DataFrame:\n    \"\"\"\n    Queries the BRENDA SOAP API to retrieve cofactor information for a given Enzyme Commission (EC) number.\n\n    Parameters:\n        ec_number (str): EC number (e.g., '1.1.1.1').\n\n    Returns:\n        pd.DataFrame: A DataFrame containing turnover number entries.\n    \"\"\"\n    # Call the SOAP API\n    email, hashed_password = get_brenda_credentials()\n    client = create_brenda_client()\n\n    parameters_cofactor = [\n        email,\n        hashed_password,\n        f'ecNumber*{ec_number}',\n        \"cofactor*\", \n        \"commentary*\", \n        \"organism*\", \n        \"ligandStructureId*\", \n        \"literature*\"\n    ]\n\n    result_cofactor = client.service.getCofactor(*parameters_cofactor)\n    data = serialize_object(result_cofactor)\n    df = pd.DataFrame(data)\n    if df.empty:\n        return []\n    cofactor = df['cofactor'].unique().tolist()\n    return cofactor\n</code></pre>"},{"location":"reference/#wildkcat.api.brenda_api.get_turnover_number_brenda","title":"<code>get_turnover_number_brenda(ec_number)</code>  <code>cached</code>","text":"<p>Queries the BRENDA SOAP API to retrieve turnover number values for a Enzyme Commission (EC) Number.</p> <p>Parameters:</p> Name Type Description Default <code>ec_number</code> <code>str</code> <p>EC number (e.g., '1.1.1.1').</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing turnover number entries.</p> Source code in <code>wildkcat/api/brenda_api.py</code> <pre><code>@lru_cache(maxsize=None)\ndef get_turnover_number_brenda(ec_number) -&gt; pd.DataFrame:\n    \"\"\"\n    Queries the BRENDA SOAP API to retrieve turnover number values for a Enzyme Commission (EC) Number.\n\n    Parameters:\n        ec_number (str): EC number (e.g., '1.1.1.1').\n\n    Returns:\n        pd.DataFrame: A DataFrame containing turnover number entries.\n    \"\"\"\n\n    email, hashed_password = get_brenda_credentials()\n    client = create_brenda_client()\n\n    # Define the parameters for the SOAP request\n\n    parameters_kcat = [\n        email,\n        hashed_password,\n        f'ecNumber*{ec_number}',\n        \"turnoverNumber*\", \n        \"turnoverNumberMaximum*\", \n        \"substrate*\", \n        \"commentary*\", \n        \"organism*\", \n        \"ligandStructureId*\", \n        \"literature*\"\n    ]\n\n    parameters_org = [\n        email,\n        hashed_password,\n        f'ecNumber*{ec_number}',\n        \"organism*\",\n        \"sequenceCode*\", \n        \"commentary*\", \n        \"literature*\",\n        \"textmining*\"\n    ]\n\n    # print(client.service.__getattr__('getTurnoverNumber').__doc__)\n    # print(client.service.__getattr__('getOrganism').__doc__)\n\n    result_kcat = client.service.getTurnoverNumber(*parameters_kcat)\n    result_organism = client.service.getOrganism(*parameters_org)\n\n    # Format the response into a DataFrame\n    data = serialize_object(result_kcat)\n    data_organism = serialize_object(result_organism)\n\n    if not data:\n        logging.warning('%s: No data found for the query in BRENDA.' % f\"{ec_number}\")\n        return pd.DataFrame()\n\n    # Remove None values (-999)\n    data = [entry for entry in data if entry.get('turnoverNumber') is not None and entry.get('turnoverNumber') != '-999']\n    if data == []:\n        logging.warning('%s: No valid data found for the query in BRENDA.' % f\"{ec_number}\")\n        return pd.DataFrame()\n\n    df = pd.DataFrame(data)\n    df_org = pd.DataFrame(data_organism)\n\n    # Format the organism response\n    df_org.drop(columns=['commentary', 'textmining'], inplace=True, errors='ignore')\n\n    # Merge on the literature column\n    df_org['literature'] = df_org['literature'].apply(lambda x: x[0] if isinstance(x, list) and len(x) &gt; 0 else x)\n    df['literature'] = df['literature'].apply(lambda x: x[0] if isinstance(x, list) and len(x) &gt; 0 else x)\n    df = pd.merge(df, df_org, on=['literature', 'organism'], how='left')\n    df.drop_duplicates(inplace=True)\n\n    # Rename columns for consistency with other APIs\n    df.rename(columns={\n        'turnoverNumber': 'value',\n        'sequenceCode' : 'UniProtKB_AC',\n        'substrate': 'Substrate',\n        'organism': 'Organism',\n        'ecNumber': 'ECNumber'}, inplace=True) \n\n    # Extract pH from commentary\n    df[\"pH\"] = df[\"commentary\"].str.extract(r\"pH\\s*([\\d\\.]+)\")\n    # Extract temperature from commentary\n    df[\"Temperature\"] = df[\"commentary\"].str.extract(r\"([\\d\\.]+)\\?C\")\n    # Convert Temperature and pH to numeric, coercing errors to NaN\n    df['Temperature'] = pd.to_numeric(df['Temperature'], errors='coerce')\n    df['pH'] = pd.to_numeric(df['pH'], errors='coerce')\n    # Extract enzyme variant from commentary\n    df[\"EnzymeVariant\"] = df[\"commentary\"].apply(get_variant)\n    # Drop unnecessary columns\n    df.drop(columns=[\"literature\", \"turnoverNumberMaximum\", \"parameter.endValue\", \"commentary\", \"ligandStructureId\"], inplace=True, errors='ignore')\n\n    # Remove the cofactor from the output \n    cofactor = get_cofactor(ec_number)\n    # Drop the lines where the cofactor is not define\n    df = df[~df['Substrate'].isin(cofactor)]   \n    # Drop duplicates\n    df.drop_duplicates(inplace=True)\n    # Add a column for the db \n    df['db'] = 'brenda' \n    return df\n</code></pre>"},{"location":"reference/#wildkcat.api.brenda_api.get_variant","title":"<code>get_variant(text)</code>","text":"<p>Extracts the enzyme variant information from the commentary text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Commentary text from BRENDA API response.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>The extracted enzyme variant information: wildtype, mutant, or None if not found.</p> Source code in <code>wildkcat/api/brenda_api.py</code> <pre><code>def get_variant(text) -&gt; str | None:\n    \"\"\"\n    Extracts the enzyme variant information from the commentary text.\n\n    Parameters:\n        text (str): Commentary text from BRENDA API response.\n\n    Returns:\n        str: The extracted enzyme variant information: wildtype, mutant, or None if not found.\n    \"\"\"\n    if text is None or pd.isna(text):\n        return None\n    text = text.lower()\n    if \"wild\" in text:  # wild-type, wildtype or wild type\n        return \"wildtype\"\n    elif any(word in text for word in [\"mutant\", \"mutated\", \"mutation\"]):\n        return \"mutant\"\n    return None\n</code></pre>"},{"location":"reference/#wildkcat.api.sabio_rk_api","title":"<code>wildkcat.api.sabio_rk_api</code>","text":""},{"location":"reference/#wildkcat.api.sabio_rk_api.get_turnover_number_sabio","title":"<code>get_turnover_number_sabio(ec_number)</code>  <code>cached</code>","text":"<p>Retrieve turnover number (kcat) data from SABIO-RK for a given EC number.</p> <p>Parameters:</p> Name Type Description Default <code>ec_number</code> <code>str</code> <p>Enzyme Commission number.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing SABIO-RK entries for kcat.</p> Source code in <code>wildkcat/api/sabio_rk_api.py</code> <pre><code>@lru_cache(maxsize=None)\ndef get_turnover_number_sabio(ec_number) -&gt; pd.DataFrame:\n    \"\"\"\n    Retrieve turnover number (kcat) data from SABIO-RK for a given EC number.\n\n    Parameters:\n        ec_number (str): Enzyme Commission number.\n\n    Returns:\n        pd.DataFrame: DataFrame containing SABIO-RK entries for kcat.\n    \"\"\"\n    base_url = 'https://sabiork.h-its.org/sabioRestWebServices/searchKineticLaws/entryIDs'\n    parameters = 'https://sabiork.h-its.org/entry/exportToExcelCustomizable'\n    entryIDs = []\n\n    # -- Retrieve entryIDs --\n    query = {'format': 'txt', 'q': f'Parametertype:\"kcat\" AND ECNumber:\"{ec_number}\"'}\n\n    # Make GET request\n    request = requests.get(base_url, params=query)\n    request.raise_for_status()\n    if request.text == \"no data found\":\n        logging.warning('%s: No data found for the query in SABIO-RK.' % f\"{ec_number}\")\n        return pd.DataFrame()  # Return empty DataFrame if no data found\n\n    entryIDs = [int(x) for x in request.text.strip().split('\\n')]\n    # Retrieve informations matching the entryIDs\n    data_field = {'entryIDs[]': entryIDs}\n    # Possible fields to retrieve:\n    # EntryID, Reaction, Buffer, ECNumber, CellularLocation, UniProtKB_AC, Tissue, Enzyme Variant, Enzymename, Organism\n    # Temperature, pH, Activator, Cofactor, Inhibitor, KeggReactionID, KineticMechanismType, Other Modifier, Parameter,\n    # Pathway, Product, PubMedID, Publication, Rate Equation, SabioReactionID, Substrate\n    query = {'format':'tsv', 'fields[]':['EntryID', 'ECNumber', 'KeggReactionID', 'Reaction', 'Substrate', 'Product', \n                                         'UniProtKB_AC', 'Organism', 'Enzyme Variant', 'Temperature', 'pH', \n                                         'Parameter']}\n\n    # Make POST request\n    request = requests.post(parameters, params=query, data=data_field)\n    request.raise_for_status()\n\n    # Format the response into a DataFrame\n    df = pd.read_csv(StringIO(request.text), sep='\\t')\n    df = df[df['parameter.name'].str.lower() == 'kcat'].reset_index(drop=True) # Keep only kcat parameters\n    # Convert Temperature and pH to numeric, coercing errors to NaN\n    df['Temperature'] = pd.to_numeric(df['Temperature'], errors='coerce')\n    df['pH'] = pd.to_numeric(df['pH'], errors='coerce')\n    # Drop unnecessary columns\n    df.drop(columns=['EntryID', 'parameter.name', 'parameter.type', 'parameter.associatedSpecies', \n                     'parameter.endValue', 'parameter.standardDeviation'], inplace=True, errors='ignore')\n    # Drop duplicates based on normalized Substrate and Product sets\n    df[\"Substrate_set\"] = df[\"Substrate\"].fillna(\"\").str.split(\";\").apply(lambda x: tuple(sorted(s.strip() for s in x if s.strip())))\n    df[\"Product_set\"] = df[\"Product\"].fillna(\"\").str.split(\";\").apply(lambda x: tuple(sorted(s.strip() for s in x if s.strip())))\n    dedup_cols = [col for col in df.columns if col not in [\"Substrate\", \"Product\"]]\n    df = df.drop_duplicates(subset=dedup_cols + [\"Substrate_set\", \"Product_set\"], keep=\"first\")\n    df = df.drop(columns=[\"Substrate_set\", \"Product_set\"])\n    # Rename columns for consistency\n    df.rename(columns={\n        'ECNumber': 'ECNumber',\n        'KeggReactionID': 'KeggReactionID',\n        'Reaction': 'Reaction',\n        'Substrate': 'Substrate',\n        'Product': 'Product',\n        'UniProtKB_AC': 'UniProtKB_AC',\n        'Organism': 'Organism',\n        'Enzyme Variant': 'EnzymeVariant',\n        'Temperature': 'Temperature',\n        'pH': 'pH',\n        'parameter.startValue': 'value',\n        'parameter.unit': 'unit'\n    }, inplace=True)\n    # Add a column for the db\n    df['db'] = 'sabio_rk'\n    return df\n</code></pre>"},{"location":"reference/#wildkcat.api.uniprot_api","title":"<code>wildkcat.api.uniprot_api</code>","text":""},{"location":"reference/#wildkcat.api.uniprot_api.catalytic_activity","title":"<code>catalytic_activity(uniprot_id)</code>  <code>cached</code>","text":"<p>Retrieves the EC (Enzyme Commission) numbers associated with the catalytic activity of a given UniProt ID.</p> <p>Parameters:</p> Name Type Description Default <code>uniprot_id</code> <code>str</code> <p>The UniProt identifier for the protein of interest.</p> required <p>Returns:</p> Type Description <code>list[str] | None</code> <p>list[str] or None: A list of EC numbers if found, otherwise None.</p> Source code in <code>wildkcat/api/uniprot_api.py</code> <pre><code>@lru_cache(maxsize=None)\ndef catalytic_activity(uniprot_id) -&gt; list[str] | None:\n    \"\"\"\n    Retrieves the EC (Enzyme Commission) numbers associated with the catalytic activity of a given UniProt ID.\n\n    Parameters:\n        uniprot_id (str): The UniProt identifier for the protein of interest.\n\n    Returns:\n        list[str] or None: A list of EC numbers if found, otherwise None.\n    \"\"\"\n    url = f\"https://rest.uniprot.org/uniprotkb/{uniprot_id}?fields=cc_catalytic_activity\"\n    response = requests.get(url)\n\n    if response.status_code == 200:\n        data = response.json()\n        ec_numbers = []\n        for comment in data.get('comments', []):\n            if comment.get('commentType') == 'CATALYTIC ACTIVITY':\n                reaction = comment.get('reaction', {})\n                ec_number = reaction.get('ecNumber')\n                if ec_number:\n                    ec_numbers.append(ec_number)\n        if len(ec_numbers) != 0:\n            return ec_numbers\n    else:\n        # logging.warning(f\"No catalytic activity found for UniProt ID {uniprot_id}\")\n        return None\n</code></pre>"},{"location":"reference/#wildkcat.api.uniprot_api.convert_uniprot_to_sequence","title":"<code>convert_uniprot_to_sequence(uniprot_id)</code>  <code>cached</code>","text":"<p>Convert a UniProt accession ID to its corresponding amino acid sequence.</p> <p>Parameters:</p> Name Type Description Default <code>uniprot_id</code> <code>str</code> <p>The UniProt accession ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>The amino acid sequence, or None if not found.</p> Source code in <code>wildkcat/api/uniprot_api.py</code> <pre><code>@lru_cache(maxsize=None)\ndef convert_uniprot_to_sequence(uniprot_id) -&gt; str | None:\n    \"\"\"\n    Convert a UniProt accession ID to its corresponding amino acid sequence.\n\n    Parameters:\n        uniprot_id (str): The UniProt accession ID.\n\n    Returns:\n        str: The amino acid sequence, or None if not found.\n    \"\"\"\n    url = f\"https://rest.uniprot.org/uniprotkb/{uniprot_id}.fasta\"\n    response = requests.get(url)\n\n    if response.status_code == 200:\n        fasta = response.text\n        lines = fasta.splitlines()\n        sequence = ''.join(lines[1:])  # Skip the header\n        return sequence\n    else:\n        # logging.warning(f\"Failed to retrieve sequence for UniProt ID {uniprot_id}\")\n        return None\n</code></pre>"},{"location":"reference/#wildkcat.api.uniprot_api.identify_catalytic_enzyme","title":"<code>identify_catalytic_enzyme(lst_uniprot_ids, ec)</code>","text":"<p>Identifies the catalytic enzyme from a list of UniProt IDs for a given EC number.</p> <p>Parameters:</p> Name Type Description Default <code>lst_uniprot_ids</code> <code>str</code> <p>A semicolon-separated string of UniProt IDs representing enzyme candidates.</p> required <code>ec</code> <code>str</code> <p>The Enzyme Commission (EC) number to match against the catalytic activity.</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>str or None: The UniProt ID of the catalytic enzyme if exactly one match is found;           None if no match or multiple matches are found.</p> Source code in <code>wildkcat/api/uniprot_api.py</code> <pre><code>def identify_catalytic_enzyme(lst_uniprot_ids, ec) -&gt; str | None:\n    \"\"\"\n    Identifies the catalytic enzyme from a list of UniProt IDs for a given EC number.\n\n    Parameters:\n        lst_uniprot_ids (str): A semicolon-separated string of UniProt IDs representing enzyme candidates.\n        ec (str): The Enzyme Commission (EC) number to match against the catalytic activity.\n\n    Returns:\n        str or None: The UniProt ID of the catalytic enzyme if exactly one match is found; \n                     None if no match or multiple matches are found.\n    \"\"\" \n    enzymes_model = lst_uniprot_ids.split(';')\n    catalytic_enzyme = []\n    for enzyme in enzymes_model:\n        if catalytic_activity(enzyme):\n            if ec in catalytic_activity(enzyme):\n                catalytic_enzyme.append(enzyme)\n    if catalytic_enzyme == []:\n        logging.warning(f\"{ec}: No catalytic enzyme found for the complex {lst_uniprot_ids}.\")\n        catalytic_enzyme = None \n    elif len(catalytic_enzyme) &gt; 1:\n        logging.warning(f\"{ec}: Multiple catalytic enzymes found for the complex {lst_uniprot_ids}.\")\n        catalytic_enzyme = ';'.join(catalytic_enzyme)\n    else:\n        catalytic_enzyme = catalytic_enzyme[0]\n    return catalytic_enzyme\n</code></pre>"},{"location":"reference/#machine-learning-preprocessing","title":"Machine Learning preprocessing","text":""},{"location":"reference/#wildkcat.machine_learning.catapro","title":"<code>wildkcat.machine_learning.catapro</code>","text":""},{"location":"reference/#wildkcat.machine_learning.catapro.convert_cid_to_smiles","title":"<code>convert_cid_to_smiles(cid)</code>","text":"<p>Converts a PubChem Compound ID (CID) to its corresponding SMILES representation.</p> <p>Parameters:</p> Name Type Description Default <code>cid</code> <code>str</code> <p>PubChem Compound ID.</p> required <p>Returns:</p> Type Description <code>list | None</code> <p>list or None: A list of SMILES strings if found, otherwise None.</p> Source code in <code>wildkcat/machine_learning/catapro.py</code> <pre><code>def convert_cid_to_smiles(cid) -&gt; list | None:    \n    \"\"\"\n    Converts a PubChem Compound ID (CID) to its corresponding SMILES representation.\n\n    Parameters:\n        cid (str): PubChem Compound ID.\n\n    Returns:\n       list or None: A list of SMILES strings if found, otherwise None.\n    \"\"\"\n    url = f\"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/{cid}/property/smiles/txt\"\n    try:\n        safe_get_with_retry = retry_api(max_retries=1, backoff_factor=2)(safe_requests_get)\n        response = safe_get_with_retry(url)\n\n        if response is None:\n            return None\n\n        response.raise_for_status()\n        smiles = response.text.strip().split('\\n')\n        return smiles\n    except:\n        return None\n</code></pre>"},{"location":"reference/#wildkcat.machine_learning.catapro.convert_kegg_compound_to_sid","title":"<code>convert_kegg_compound_to_sid(kegg_compound_id)</code>","text":"<p>Convert the KEGG compound ID to the PubChem Substance ID (SID).</p> <p>Parameters:</p> Name Type Description Default <code>kegg_compound_id</code> <code>str</code> <p>KEGG compound ID.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>The PubChem SID if found, otherwise None.</p> Source code in <code>wildkcat/machine_learning/catapro.py</code> <pre><code>def convert_kegg_compound_to_sid(kegg_compound_id) -&gt; str | None:\n    \"\"\"\n    Convert the KEGG compound ID to the PubChem Substance ID (SID).\n\n    Parameters:\n        kegg_compound_id (str): KEGG compound ID.\n\n    Returns:\n        str: The PubChem SID if found, otherwise None.\n    \"\"\"\n    url = f\"https://rest.kegg.jp/conv/pubchem/compound:{kegg_compound_id}\"\n    safe_get_with_retry = retry_api(max_retries=2, backoff_factor=2)(safe_requests_get)\n    response = safe_get_with_retry(url)\n\n    if response is None:\n        return None\n\n    if response.status_code != 200:\n        return None\n\n    match = re.search(r'pubchem:\\s*(\\d+)', response.text)\n    sid = match.group(1) if match else None\n    return sid\n</code></pre>"},{"location":"reference/#wildkcat.machine_learning.catapro.convert_kegg_to_smiles","title":"<code>convert_kegg_to_smiles(kegg_compound_id)</code>  <code>cached</code>","text":"<p>Convert the KEGG compound ID to the PubChem Compound ID (CID).</p> <p>Parameters:</p> Name Type Description Default <code>kegg_compound_id</code> <code>str</code> <p>KEGG compound ID.</p> required <p>Returns:</p> Type Description <code>list | None</code> <p>list or None: A list of SMILES strings if found, otherwise None.</p> Source code in <code>wildkcat/machine_learning/catapro.py</code> <pre><code>@lru_cache(maxsize=None)\ndef convert_kegg_to_smiles(kegg_compound_id) -&gt; list | None:\n    \"\"\"\n    Convert the KEGG compound ID to the PubChem Compound ID (CID).\n\n    Parameters:\n        kegg_compound_id (str): KEGG compound ID.\n\n    Returns:\n        list or None: A list of SMILES strings if found, otherwise None.\n    \"\"\"\n    sid = convert_kegg_compound_to_sid(kegg_compound_id)\n    if sid is None:\n        logging.warning('%s: Failed to retrieve SID for KEGG compound ID' % (kegg_compound_id))\n        return None\n    cid = convert_sid_to_cid(sid)\n    if cid is None:\n        logging.warning('%s: Failed to retrieve CID for KEGG compound ID' % (kegg_compound_id))\n        return None\n    smiles = convert_cid_to_smiles(cid)\n    if smiles is None:\n        logging.warning('%s: Failed to retrieve SMILES for KEGG compound ID' % (kegg_compound_id))\n        return None\n    return smiles\n</code></pre>"},{"location":"reference/#wildkcat.machine_learning.catapro.convert_sid_to_cid","title":"<code>convert_sid_to_cid(sid)</code>","text":"<p>Converts a PubChem Substance ID (SID) to the corresponding Compound ID (CID).</p> <p>Parameters:</p> Name Type Description Default <code>sid</code> <code>str</code> <p>PubChem Substance ID.</p> required <p>Returns:</p> Type Description <code>int | None</code> <p>int or None: The corresponding PubChem Compound ID (CID), or None if not found.</p> Source code in <code>wildkcat/machine_learning/catapro.py</code> <pre><code>def convert_sid_to_cid(sid) -&gt; int | None:\n    \"\"\"\n    Converts a PubChem Substance ID (SID) to the corresponding Compound ID (CID).\n\n    Parameters:\n        sid (str): PubChem Substance ID.\n\n    Returns:\n        int or None: The corresponding PubChem Compound ID (CID), or None if not found.\n    \"\"\"\n    url = f\"https://pubchem.ncbi.nlm.nih.gov/rest/pug/substance/sid/{sid}/cids/JSON\"\n    safe_get_with_retry = retry_api(max_retries=1, backoff_factor=2)(safe_requests_get)\n    response = safe_get_with_retry(url)\n\n    if response is None:\n        return None\n\n    if response.status_code == 200:\n        try:\n            cid = response.json()['InformationList']['Information'][0]['CID'][0]\n        except (KeyError, IndexError):\n            cid = None\n    return cid\n</code></pre>"},{"location":"reference/#wildkcat.machine_learning.catapro.create_catapro_input_file","title":"<code>create_catapro_input_file(kcat_df)</code>","text":"<p>Generate CataPro input file and a mapping of substrate KEGG IDs to SMILES.</p> <p>Parameters:</p> Name Type Description Default <code>kcat_df</code> <code>DataFrame</code> <p>Input DataFrame containing kcat information.</p> required <p>Returns:</p> Name Type Description <code>catapro_input_df</code> <code>DataFrame</code> <p>DataFrame for CataPro input.</p> <code>substrates_to_smiles</code> <code>dict</code> <p>Mapping KEGG ID &lt;-&gt; SMILES.</p> Source code in <code>wildkcat/machine_learning/catapro.py</code> <pre><code>def create_catapro_input_file(kcat_df):\n    \"\"\"\n    Generate CataPro input file and a mapping of substrate KEGG IDs to SMILES.\n\n    Parameters: \n        kcat_df (pd.DataFrame): Input DataFrame containing kcat information.\n\n    Returns:\n        catapro_input_df (pd.DataFrame): DataFrame for CataPro input.\n        substrates_to_smiles (dict): Mapping KEGG ID &lt;-&gt; SMILES.\n    \"\"\"\n    catapro_input = []\n    substrates_to_smiles = {}\n\n    counter_no_catalytic, counter_kegg_no_matching, counter_rxn_covered, counter_cofactor = 0, 0, 0, 0\n    for _, row in tqdm(kcat_df.iterrows(), total=len(kcat_df), desc=\"Generating CataPro input\"):\n        uniprot = row['uniprot']\n        ec_code = row['ec_code']\n\n        if len(uniprot.split(';')) &gt; 1:       \n            catalytic_enzyme = identify_catalytic_enzyme(uniprot, ec_code)\n            if catalytic_enzyme is None or (\";\" in str(catalytic_enzyme)):\n                counter_no_catalytic += 1\n                continue\n            else: \n                uniprot = catalytic_enzyme\n\n        # If the number of KEGG Compound IDs is not matching the number of names, continue \n        if len([s for s in row['substrates_kegg'].split(';') if s]) != len(row['substrates_name'].split(';')):\n            logging.warning(f\"Number of KEGG compounds IDs does not match number of names for {ec_code}: {uniprot}.\")\n            counter_kegg_no_matching += 1\n            continue\n\n        sequence = convert_uniprot_to_sequence(uniprot) \n        if sequence is None:\n            continue\n\n        smiles_list = []\n        names = row['substrates_name'].split(';')\n        kegg_ids = row['substrates_kegg'].split(';')\n\n        # Get the cofactor for the EC code\n        cofactor = get_cofactor(ec_code) \n\n        for name, kegg_compound_id in zip(names, kegg_ids):\n            if name.lower() in [c.lower() for c in cofactor]:  # TODO: Should we add a warning if no cofactor is found for a reaction? \n                counter_cofactor += 1\n                continue\n            smiles = convert_kegg_to_smiles(kegg_compound_id)\n            if smiles is not None:\n                smiles_str = smiles[0]  # TODO: If multiple SMILES, take the first one ? \n                smiles_list.append(smiles_str)\n                substrates_to_smiles[kegg_compound_id] = smiles_str\n\n        if len(smiles_list) &gt; 0:\n            for smiles in smiles_list:\n                catapro_input.append({\n                    \"Enzyme_id\": uniprot,\n                    \"type\": \"wild\",\n                    \"sequence\": sequence,\n                    \"smiles\": smiles\n                })\n\n        counter_rxn_covered += 1\n\n    # Generate CataPro input file\n    catapro_input_df = pd.DataFrame(catapro_input)\n    # Remove duplicates\n    before_duplicates_filter = len(catapro_input_df)\n    catapro_input_df = catapro_input_df.drop_duplicates().reset_index(drop=True)\n    nb_lines_dropped = before_duplicates_filter - len(catapro_input_df)\n    # Generate reverse mapping from SMILES to KEGG IDs as TSV\n    substrates_to_smiles_df = pd.DataFrame(list(substrates_to_smiles.items()), columns=['kegg_id', 'smiles'])\n\n    report_statistics = {\n        \"rxn_covered\": counter_rxn_covered,\n        \"cofactor_identified\": counter_cofactor,\n        \"no_catalytic\": counter_no_catalytic,\n        \"kegg_no_matching\": counter_kegg_no_matching,\n        \"duplicates_enzyme_substrates\": nb_lines_dropped,\n    }\n\n    return catapro_input_df, substrates_to_smiles_df, report_statistics\n</code></pre>"},{"location":"reference/#wildkcat.machine_learning.catapro.integrate_catapro_predictions","title":"<code>integrate_catapro_predictions(kcat_df, substrates_to_smiles, catapro_predictions_df)</code>","text":"<p>Integrates Catapro predictions into an kcat file. If multiple values are provided for a single combination of EC, Enzyme, Substrate, the minimum value is taken.</p> <p>Parameters:</p> Name Type Description Default <code>kcat_df</code> <code>DataFrame</code> <p>Input DataFrame containing kcat information.</p> required <code>substrates_to_smiles</code> <code>DataFrame</code> <p>DataFrame mapping KEGG ID &lt;-&gt; SMILES.</p> required <code>catapro_predictions_df</code> <code>DataFrame</code> <p>DataFrame containing Catapro model predictions</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: The input kcat_df with an additional column 'catapro_predicted_kcat_s' containing the integrated Catapro predicted kcat(s^-1) values.</p> Source code in <code>wildkcat/machine_learning/catapro.py</code> <pre><code>def integrate_catapro_predictions(kcat_df, substrates_to_smiles, catapro_predictions_df) -&gt; pd.DataFrame:\n    \"\"\"\n    Integrates Catapro predictions into an kcat file.\n    If multiple values are provided for a single combination of EC, Enzyme, Substrate, the minimum value is taken.\n\n    Parameters:\n        kcat_df (pd.DataFrame): Input DataFrame containing kcat information.\n        substrates_to_smiles (pd.DataFrame): DataFrame mapping KEGG ID &lt;-&gt; SMILES.\n        catapro_predictions_df (pd.DataFrame): DataFrame containing Catapro model predictions\n\n    Returns:\n        pd.DataFrame: The input kcat_df with an additional column 'catapro_predicted_kcat_s' containing\n            the integrated Catapro predicted kcat(s^-1) values.\n    \"\"\"\n    # Convert pred_log10[kcat(s^-1)] to kcat(s^-1)\n    catapro_predictions_df['kcat_s'] = 10 ** catapro_predictions_df['pred_log10[kcat(s^-1)]']\n    catapro_predictions_df['uniprot'] = catapro_predictions_df['fasta_id'].str.replace('_wild', '', regex=False) # Extract UniProt ID\n\n    # Match the SMILES to KEGG IDs using substrates_to_smiles\n    # If multiple KEGG IDs are found for a single SMILES, they are concatenated\n    smiles_to_kegg = (\n        substrates_to_smiles.groupby('smiles')['kegg_id']\n        .apply(lambda x: ';'.join(sorted(set(x))))\n    )\n    catapro_predictions_df['substrates_kegg'] = catapro_predictions_df['smiles'].map(smiles_to_kegg)\n\n    catapro_map = catapro_predictions_df.set_index(['uniprot', 'substrates_kegg'])['kcat_s'].to_dict()\n\n    def get_min_pred_kcat(row):\n        uniprot = row['uniprot']\n        kegg_ids = str(row['substrates_kegg']).split(';')\n        kcat_values = [\n            catapro_map.get((uniprot, kegg_id))\n            for kegg_id in kegg_ids\n            if (uniprot, kegg_id) in catapro_map\n        ]\n        return min(kcat_values) if kcat_values else None  # If multiple substrates, take the minimum kcat value\n\n    kcat_df['catapro_predicted_kcat_s'] = kcat_df.apply(get_min_pred_kcat, axis=1)\n    return kcat_df\n</code></pre>"},{"location":"reference/#generate-reports","title":"Generate reports","text":""},{"location":"reference/#wildkcat.utils.generate_reports","title":"<code>wildkcat.utils.generate_reports</code>","text":""},{"location":"reference/#wildkcat.utils.generate_reports.report_extraction","title":"<code>report_extraction(model, df, report_statistics, output_folder, shader=False)</code>","text":"<p>Generates a detailed HTML report summarizing kcat extraction results from a metabolic model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The metabolic model object containing reactions, metabolites, and genes.</p> required <code>df</code> <code>DataFrame</code> <p>DataFrame containing data from the run_extraction function.</p> required <code>report_statistics</code> <code>dict</code> <p>Dictionary with statistics about EC code assignment and extraction issues.</p> required <code>output_folder</code> <code>str</code> <p>Path to the output folder where the report will be saved.</p> required <code>shader</code> <code>bool</code> <p>If True, includes a shader canvas background in the report. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The function saves the generated HTML report to 'reports/extract_kcat_report.html'.</p> Source code in <code>wildkcat/utils/generate_reports.py</code> <pre><code>def report_extraction(model, df, report_statistics, output_folder, shader=False) -&gt; None:\n    \"\"\"\n    Generates a detailed HTML report summarizing kcat extraction results from a metabolic model.\n\n    Parameters: \n        model (cobra.Model): The metabolic model object containing reactions, metabolites, and genes.\n        df (pandas.DataFrame): DataFrame containing data from the run_extraction function.\n        report_statistics (dict): Dictionary with statistics about EC code assignment and extraction issues.\n        output_folder (str): Path to the output folder where the report will be saved.\n        shader (bool, optional): If True, includes a shader canvas background in the report. Default is False.\n\n    Returns: \n        None: The function saves the generated HTML report to 'reports/extract_kcat_report.html'. \n    \"\"\"\n    # Model statistics\n    nb_model_reactions = len(model.reactions)\n    nb_model_metabolites = len(model.metabolites)\n    nb_model_genes = len(model.genes)\n    unique_ec_codes = []\n    for rxn in model.reactions:\n        ec_code = rxn.annotation.get('ec-code')\n        if ec_code:\n            if isinstance(ec_code, str):\n                ec_code = [ec_code.strip()]\n            elif isinstance(ec_code, list):\n                ec_code = [x.strip() for x in ec_code if x.strip()]\n            else:\n                ec_code = []\n            unique_ec_codes.extend(ec_code)\n    nb_model_ec_codes = len(set(unique_ec_codes))\n\n    # Kcat statistics\n    nb_reactions = df['rxn'].nunique()\n    nb_ec_codes = df['ec_code'].nunique()\n\n    nb_ec_codes_transferred = report_statistics.get('transferred_ec_codes', 0)\n    nb_ec_codes_incomplete = report_statistics.get('incomplete_ec_codes', 0)\n    nb_reactions_dropped = report_statistics.get('nb_of_reactions_due_to_unconsistent_ec', 0)\n    nb_lines_dropped = report_statistics.get('nb_of_lines_dropped_due_to_unconsistent_ec', 0)\n\n    rxn_coverage = 100.0 * nb_reactions / nb_model_reactions if nb_model_reactions else 0\n\n    percent_ec_retrieved = 100.0 * nb_ec_codes / nb_model_ec_codes if nb_model_ec_codes else 0\n\n    # Pie Chart\n    pie_data = {\n        \"Retrieved\": nb_ec_codes,\n        \"Transferred\": nb_ec_codes_transferred,\n        \"Incomplete\": nb_ec_codes_incomplete,\n    }\n\n    pie_data = {k: v for k, v in pie_data.items() if v &gt; 0}\n\n    fig = px.pie(\n        names=list(pie_data.keys()),\n        values=list(pie_data.values()),\n        color_discrete_sequence=[\"#55bb55\", \"#ee9944\", \"#cc4455\"]\n    )\n    fig.update_traces(textinfo=\"percent+label\", textfont_size=16)\n    fig.update_layout(\n        title=\"\",\n        title_font=dict(size=30, color=\"black\"),\n        showlegend=True\n    )\n\n    pie_chart_html = fig.to_html(full_html=False, include_plotlyjs=\"cdn\")\n\n    # Time\n    generated_time = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    # Html report\n    html = f\"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n        &lt;title&gt;Extract kcat Report&lt;/title&gt;\n        {report_style()}\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;header&gt;\n            &lt;canvas id=\"shader-canvas\"&gt;&lt;/canvas&gt;\n            &lt;div class=\"overlay\"&gt;\n                &lt;h1&gt;Extract k&lt;sub&gt;cat&lt;/sub&gt; Report&lt;/h1&gt;\n                &lt;p&gt;Generated on {generated_time}&lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/header&gt;\n\n        &lt;div class=\"container\"&gt;\n            &lt;!-- Model Overview --&gt;\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Model Overview&lt;/h2&gt;\n                &lt;div class=\"stats-grid\"&gt;\n                    &lt;div class=\"stat-box\"&gt;\n                        &lt;h3&gt;{model.id}&lt;/h3&gt;\n                        &lt;p&gt;Model ID&lt;/p&gt;\n                    &lt;/div&gt;\n                    &lt;div class=\"stat-box\"&gt;\n                        &lt;h3&gt;{nb_model_reactions}&lt;/h3&gt;\n                        &lt;p&gt;Reactions&lt;/p&gt;\n                    &lt;/div&gt;\n                    &lt;div class=\"stat-box\"&gt;\n                        &lt;h3&gt;{nb_model_metabolites}&lt;/h3&gt;\n                        &lt;p&gt;Metabolites&lt;/p&gt;\n                    &lt;/div&gt;\n                    &lt;div class=\"stat-box\"&gt;\n                        &lt;h3&gt;{nb_model_genes}&lt;/h3&gt;\n                        &lt;p&gt;Genes&lt;/p&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n\n            &lt;!-- kcat Extraction Table --&gt;\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;k&lt;sub&gt;cat&lt;/sub&gt; Extraction Statistics&lt;/h2&gt;\n                &lt;table&gt;\n                    &lt;tr&gt;\n                        &lt;th&gt;Metric&lt;/th&gt;\n                        &lt;th&gt;Value&lt;/th&gt;\n                        &lt;th&gt;Visualization&lt;/th&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Reactions with EC info&lt;/td&gt;\n                        &lt;td&gt;{nb_reactions} ({rxn_coverage:.1f}%)&lt;/td&gt;\n                        &lt;td&gt;\n                            &lt;div class=\"progress\"&gt;\n                                &lt;div class=\"progress-bar-table\" style=\"width:{rxn_coverage}%;\"&gt;&lt;/div&gt;\n                            &lt;/div&gt;\n                        &lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;EC codes retrieved in KEGG&lt;/td&gt;\n                        &lt;td&gt;{nb_ec_codes} ({percent_ec_retrieved:.1f}%)&lt;/td&gt;\n                        &lt;td&gt;\n                            &lt;div class=\"progress\"&gt;\n                                &lt;div class=\"progress-bar-table\" style=\"width:{percent_ec_retrieved}%;\"&gt;&lt;/div&gt;\n                            &lt;/div&gt;\n                        &lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Total rows in output (Rxn - EC - Enzyme - Substrate)&lt;/td&gt;\n                        &lt;td&gt;{len(df) - 1}&lt;/td&gt;\n                        &lt;td&gt;-&lt;/td&gt;\n                    &lt;/tr&gt;\n                &lt;/table&gt;\n            &lt;/div&gt;\n\n            &lt;!-- EC Issues Table --&gt;\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Issues in EC Assignment&lt;/h2&gt;\n                &lt;table&gt;\n                    &lt;tr&gt;\n                        &lt;th&gt;Cases&lt;/th&gt;\n                        &lt;th&gt;Count&lt;/th&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Transferred EC codes&lt;/td&gt;\n                        &lt;td&gt;{nb_ec_codes_transferred}&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Incomplete EC codes&lt;/td&gt;\n                        &lt;td&gt;{nb_ec_codes_incomplete}&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Number of reactions dropped due to inconsistent EC codes&lt;/td&gt;\n                        &lt;td&gt;{nb_reactions_dropped}&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Number of k&lt;sub&gt;cat&lt;/sub&gt; values dropped due to inconsistent EC codes&lt;/td&gt;\n                        &lt;td&gt;{nb_lines_dropped}&lt;/td&gt;\n                    &lt;/tr&gt;\n                &lt;/table&gt;\n            &lt;/div&gt;\n\n            &lt;!-- Pie Chart Section --&gt;\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;EC Distribution&lt;/h2&gt;\n                {pie_chart_html}\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;footer&gt;WILDkCAT&lt;/footer&gt;\n    \"\"\"\n    if shader:\n        html += report_shader()\n    else: \n        html += report_simple()\n    html += \"\"\"\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    # Save report\n    os.makedirs(os.path.join(output_folder, \"reports\"), exist_ok=True)\n    report_path = os.path.join(output_folder, \"reports/extract_report.html\")\n    with open(report_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(html)\n    logging.info(f\"HTML report saved to '{report_path}'\")\n</code></pre>"},{"location":"reference/#wildkcat.utils.generate_reports.report_final","title":"<code>report_final(model, final_df, output_folder, shader=False)</code>","text":"<p>Generate a full HTML report summarizing retrieval results, including kcat distributions and coverage.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The metabolic model object containing reactions, metabolites, and genes.</p> required <code>final_df</code> <code>DataFrame</code> <p>DataFrame containing the final kcat assignments from run_prediction_part2 function</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The function saves the generated HTML report to 'reports/general_report.html'.</p> Source code in <code>wildkcat/utils/generate_reports.py</code> <pre><code>def report_final(model, final_df, output_folder, shader=False) -&gt; None:\n    \"\"\"\n    Generate a full HTML report summarizing retrieval results, including kcat distributions and coverage.\n\n    Parameters:\n        model (cobra.Model): The metabolic model object containing reactions, metabolites, and genes.\n        final_df (pd.DataFrame): DataFrame containing the final kcat assignments from run_prediction_part2 function\n\n    Returns: \n        None: The function saves the generated HTML report to 'reports/general_report.html'.\n    \"\"\"\n    # Model information \n    nb_model_reactions = len(model.reactions)\n    nb_model_metabolites = len(model.metabolites)\n    nb_model_genes = len(model.genes)\n\n\n    df = final_df.copy()\n    df[\"db\"] = df[\"db\"].fillna(\"Unknown\")\n    generated_time = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    # Utility to convert matplotlib figures to base64 &lt;img&gt;\n    def fig_to_base64(fig):\n        buf = BytesIO()\n        fig.savefig(buf, format=\"png\", bbox_inches=\"tight\")\n        buf.seek(0)\n        encoded = base64.b64encode(buf.read()).decode(\"utf-8\")\n        plt.close(fig)\n        return f'&lt;div class=\"plot-container\"&gt;&lt;img src=\"data:image/png;base64,{encoded}\"&gt;&lt;/div&gt;'\n\n    # Distribution plots\n    def plot_kcat_distribution_stacked(column_name, title, source):\n        # Ensure numeric kcat\n        df[column_name] = pd.to_numeric(df[column_name], errors='coerce')\n\n        # Drop NaNs for both columns\n        valid_df = df.dropna(subset=[column_name, source])\n        kcat_values = valid_df[column_name]\n\n        total = len(df)\n        matched = len(kcat_values)\n        match_percent = matched / total * 100 if total else 0\n\n        if not kcat_values.empty:\n            # Define log bins\n            min_exp = int(np.floor(np.log10(max(1e-6, kcat_values.min()))))\n            max_exp = int(np.ceil(np.log10(kcat_values.max())))\n            bins = np.logspace(min_exp, max_exp, num=40)\n\n            # Prepare data for stacked histogram\n            sources = valid_df[source].unique()\n            grouped_values = [valid_df.loc[valid_df[source] == src, column_name] for src in sources]\n\n            # Colors from seaborn palette\n            # Fixed color mapping\n            color_map = {\n                \"brenda\": \"#55bb55\",   # green\n                \"sabio_rk\": \"#2277cc\", # blue\n                \"catapro\": \"#eedd00\",  # yellow\n                \"Unknown\": \"#dddddd\"   # gray\n            }\n            colors = [color_map.get(src, \"#999999\") for src in sources]  # fallback gray\n\n            # Plot\n            fig, ax = plt.subplots(figsize=(10, 6))\n            ax.hist(grouped_values, bins=bins, stacked=True,\n                    color=colors, label=sources, edgecolor=\"white\", linewidth=0.7)\n\n            ax.set_xscale(\"log\")\n            ax.set_xlim([10**min_exp / 1.5, 10**max_exp * 1.5])\n            ax.xaxis.set_major_formatter(LogFormatter(10))\n\n            ax.set_xlabel(\"kcat (s\u207b\u00b9)\", fontsize=12)\n            ax.set_ylabel(\"Count\", fontsize=12)\n            ax.set_title(f\"{title} (n={matched}, {match_percent:.1f}%)\", fontsize=13)\n            ax.legend(title=\"Source\")\n\n            return fig_to_base64(fig)\n\n        return \"&lt;p&gt;No valid values available for plotting.&lt;/p&gt;\"\n\n    img_final = plot_kcat_distribution_stacked(\n        'kcat', \"kcat distribution\", \"db\"\n    )\n\n    # Coverage\n    db_counts = df[\"db\"].fillna(\"Unknown\").value_counts()\n    total_db = db_counts.sum()\n\n    colors = {\n        \"brenda\": \"#55bb55\",      # blue\n        \"sabio_rk\": \"#2277cc\",    # orange\n        \"catapro\": \"#eedd00\",     # green\n        \"Unknown\": \"#ddd\"      # gray\n    }\n\n    db_colors = {db: colors.get(db, \"#ddd\") for db in db_counts.index}\n\n    progress_segments = \"\"\n    legend_items = \"\"\n    for db, count in db_counts.items():\n        percent = count / total_db * 100\n        progress_segments += f\"\"\"\n            &lt;div class=\"progress-segment\" style=\"width:{percent:.1f}%; background-color:{db_colors[db]};\"\n                title=\"{db.capitalize()}: {percent:.1f}%\"&gt;&lt;/div&gt;\n        \"\"\"\n        legend_items += f\"\"\"\n            &lt;span style=\"display:flex; align-items:center; margin-right:15px; margin-bottom:5px;\"&gt;\n                &lt;span style=\"display:flex; align-items:center; width:16px; height:16px; \n                            background:{db_colors[db]}; border:1px solid #000; margin-right:5px;\"&gt;&lt;/span&gt;\n                {db.capitalize()} ({percent:.1f}%)\n            &lt;/span&gt;\n        \"\"\"\n\n    progress_bar = f\"\"\"\n        &lt;div class=\"progress-multi\" style=\"height: 18px; margin-bottom:18px; display:flex;\"&gt;\n            {progress_segments}\n        &lt;/div&gt;\n        &lt;div style=\"margin-top:10px; display:flex; justify-content:center; flex-wrap: wrap;\"&gt;{legend_items}&lt;/div&gt;\n    \"\"\"\n\n    # Statistics \n    grouped = df.groupby(\"rxn\")\n    rxns_with_kcat = grouped[\"kcat\"].apply(lambda x: x.notna().any())\n    nb_rxn = grouped.ngroups\n    nb_rxn_with_kcat = rxns_with_kcat.sum()\n    coverage = nb_rxn_with_kcat / nb_rxn\n    coverage_total = nb_rxn_with_kcat / nb_model_reactions\n\n    kcat_values = df[\"kcat\"].dropna()\n    total = len(df)\n    matched = len(kcat_values)\n    match_percent = matched / total\n\n    # HTML\n    html = f\"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;title&gt;WILDkCAT Report&lt;/title&gt;\n        {report_style()}\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;header&gt;\n            &lt;canvas id=\"shader-canvas\"&gt;&lt;/canvas&gt;\n            &lt;div class=\"overlay\"&gt;\n                &lt;h1&gt;WILDkCAT Report&lt;/h1&gt;\n                &lt;p&gt;Generated on {generated_time}&lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/header&gt;\n\n        &lt;div class=\"container\"&gt;\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Introduction&lt;/h2&gt;\n                &lt;p style=\"margin-bottom:20px; font-size:14px; color:#555; text-align: justify;\"&gt;\n                    This report provides a summary of the performance of k&lt;sub&gt;cat&lt;/sub&gt; value extraction, retrieval, and prediction for the specified metabolic model. \n                    It presents statistics on k&lt;sub&gt;cat&lt;/sub&gt; values successfully retrieved, whether experimental or predicted.\n                &lt;/p&gt;\n                &lt;p style=\"margin-bottom:20px; font-size:14px; color:#555; text-align: justify;\"&gt;\n                    The output file, containing the full list of k&lt;sub&gt;cat&lt;/sub&gt; values associated with each reaction, are available as a tab-separated file (TSV) at the default output path: &lt;code&gt;output/model_name_kcat_full&lt;/code&gt;.\n                &lt;/p&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Model Overview&lt;/h2&gt;\n                &lt;div class=\"stats-grid\"&gt;\n                    &lt;div class=\"stat-box\"&gt;\n                        &lt;h3&gt;{model.id}&lt;/h3&gt;\n                        &lt;p&gt;Model ID&lt;/p&gt;\n                    &lt;/div&gt;\n                    &lt;div class=\"stat-box\"&gt;\n                        &lt;h3&gt;{nb_model_reactions}&lt;/h3&gt;\n                        &lt;p&gt;Reactions&lt;/p&gt;\n                    &lt;/div&gt;\n                    &lt;div class=\"stat-box\"&gt;\n                        &lt;h3&gt;{nb_model_metabolites}&lt;/h3&gt;\n                        &lt;p&gt;Metabolites&lt;/p&gt;\n                    &lt;/div&gt;\n                    &lt;div class=\"stat-box\"&gt;\n                        &lt;h3&gt;{nb_model_genes}&lt;/h3&gt;\n                        &lt;p&gt;Genes&lt;/p&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"card\" style=\"padding:20px; margin-bottom:20px;\"&gt;\n                &lt;h2 style=\"margin-bottom:10px;\"&gt;Coverage&lt;/h2&gt;\n\n                &lt;!-- Explanation --&gt;\n                &lt;p style=\"margin-bottom:20px; font-size:14px; color:#555; text-align: justify;\"&gt;\n                    The coverage section reports the number of k&lt;sub&gt;cat&lt;/sub&gt; values retrieved for the model and the number of reactions that have at least one \n                    associated k&lt;sub&gt;cat&lt;/sub&gt; value, whether experimental or predicted. This provides a measure of how extensively the model\u2019s reactions are \n                    annotated with kinetic data.\n                &lt;/p&gt;\n                &lt;p style=\"margin-bottom:20px; font-size:14px; color:#555; text-align: justify;\"&gt;\n                    Higher coverage indicates that a larger fraction of reactions are constrained by k&lt;sub&gt;cat&lt;/sub&gt; values, \n                    improving the accuracy and reliability of enzyme-constrained simulations.\n                &lt;/p&gt;\n\n                &lt;!-- Global coverage progress bar --&gt;\n                {progress_bar}        \n\n                &lt;!-- Detailed stats --&gt;\n                &lt;table class=\"table\" style=\"width:100%; border-spacing:0; border-collapse: collapse;\"&gt;\n                    &lt;tbody&gt;\n                        &lt;tr&gt;\n                            &lt;td style=\"padding:8px 12px;\"&gt;Reactions with EC information with at least one kcat values&lt;/td&gt;\n                            &lt;td style=\"padding:8px 12px;\"&gt;{nb_rxn_with_kcat} ({coverage:.1%})&lt;/td&gt;\n                            &lt;td style=\"width:40%;\"&gt;\n                                &lt;div class=\"progress\" style=\"height:18px;\"&gt;\n                                    &lt;div class=\"progress-bar-table\" \n                                        style=\"width:{coverage:.1%}; background-color:#4caf50;\"&gt;\n                                    &lt;/div&gt;\n                                &lt;/div&gt;\n                            &lt;/td&gt;\n                        &lt;/tr&gt;\n                        &lt;tr&gt;\n                            &lt;td style=\"padding:8px 12px;\"&gt;Reactions in the model with at least one kcat values&lt;/td&gt;\n                            &lt;td style=\"padding:8px 12px;\"&gt;{nb_rxn_with_kcat} ({coverage_total:.1%})&lt;/td&gt;\n                            &lt;td style=\"width:40%;\"&gt;\n                                &lt;div class=\"progress\" style=\"height:18px;\"&gt;\n                                    &lt;div class=\"progress-bar-table\" \n                                        style=\"width:{coverage_total:.1%}; background-color:#4caf50;\"&gt;\n                                    &lt;/div&gt;\n                                &lt;/div&gt;\n                            &lt;/td&gt;\n                        &lt;/tr&gt;\n                        &lt;tr&gt;\n                            &lt;td style=\"padding:8px 12px;\"&gt;k&lt;sub&gt;cat&lt;/sub&gt; values retrieved &lt;/td&gt;\n                            &lt;td style=\"padding:8px 12px;\"&gt;{matched} ({match_percent:.1%})&lt;/td&gt;\n                            &lt;td style=\"width:40%;\"&gt;\n                                &lt;div class=\"progress\" style=\"height:18px;\"&gt;\n                                    &lt;div class=\"progress-bar-table\" \n                                        style=\"width:{match_percent:.1%}; background-color:#4caf50;\"&gt;\n                                    &lt;/div&gt;\n                                &lt;/div&gt;\n                            &lt;/td&gt;\n                        &lt;/tr&gt;\n                    &lt;/tbody&gt;\n                &lt;/table&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;k&lt;sub&gt;cat&lt;/sub&gt; Distribution&lt;/h2&gt;\n                &lt;div class=\"img-section\"&gt;\n                    {img_final}\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;footer&gt;WILDkCAT&lt;/footer&gt;\n    \"\"\"\n    if shader:\n        html += report_shader()\n    else: \n        html += report_simple()\n    html += \"\"\"\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    os.makedirs(os.path.join(output_folder, \"reports\"), exist_ok=True)\n    report_path = os.path.join(output_folder, \"reports/general_report.html\")\n    with open(report_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(html)\n\n    logging.info(f\"HTML report saved to '{report_path}'\")\n    return report_path\n</code></pre>"},{"location":"reference/#wildkcat.utils.generate_reports.report_prediction_input","title":"<code>report_prediction_input(catapro_df, report_statistics, output_folder, shader=False)</code>","text":"<p>Generate a detailed HTML report summarizing the kcat prediction input statistics.</p> <p>Parameters:</p> Name Type Description Default <code>catapro_df</code> <code>DataFrame</code> <p>DataFrame containing the CataPro input data.</p> required <code>report_statistics</code> <code>dict</code> <p>Dictionary with statistics about the prediction input.</p> required <code>output_folder</code> <code>str</code> <p>Path to the output folder where the report will be saved.</p> required <code>shader</code> <code>bool</code> <p>If True, includes a shader canvas background in the report. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The function saves the generated HTML report to 'reports/predict_kcat_report.html'.</p> Source code in <code>wildkcat/utils/generate_reports.py</code> <pre><code>def report_prediction_input(catapro_df, report_statistics, output_folder, shader=False) -&gt; None: \n    \"\"\"\n    Generate a detailed HTML report summarizing the kcat prediction input statistics.\n\n    Parameters:\n        catapro_df (pd.DataFrame): DataFrame containing the CataPro input data.\n        report_statistics (dict): Dictionary with statistics about the prediction input.\n        output_folder (str): Path to the output folder where the report will be saved.\n        shader (bool, optional): If True, includes a shader canvas background in the report. Default is False.\n\n    Returns:\n        None: The function saves the generated HTML report to 'reports/predict_kcat_report.html'.\n    \"\"\"\n    # CataPro Statistics \n    total_catapro_entries = len(catapro_df) - 1\n\n    # Report Statistics\n    rxn_covered = report_statistics['rxn_covered']\n    cofactors_covered = report_statistics['cofactor_identified']\n    no_catalytic = report_statistics['no_catalytic']\n    kegg_missing = report_statistics['kegg_no_matching']\n    duplicates = report_statistics['duplicates_enzyme_substrates']\n    missing_enzyme = report_statistics['missing_enzymes']\n\n    total_rxn = rxn_covered + no_catalytic + kegg_missing + missing_enzyme\n    rxn_coverage = (rxn_covered / total_rxn * 100) if total_rxn &gt; 0 else 0\n\n    # Time\n    generated_time = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    # Html report\n    html = f\"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n        &lt;title&gt;Predict kcat Report&lt;/title&gt;\n        {report_style()}\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;header&gt;\n            &lt;canvas id=\"shader-canvas\"&gt;&lt;/canvas&gt;\n            &lt;div class=\"overlay\"&gt;\n                &lt;h1&gt;Predict k&lt;sub&gt;cat&lt;/sub&gt; Report&lt;/h1&gt;\n                &lt;p&gt;Generated on {generated_time}&lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/header&gt;\n\n        &lt;div class=\"container\"&gt;\n            &lt;!-- CataPro Overview --&gt;\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Overview&lt;/h2&gt;\n                &lt;div class=\"stats-grid\"&gt;\n                    &lt;div class=\"stat-box\"&gt;\n                        &lt;h3&gt;{total_rxn}&lt;/h3&gt;\n                        &lt;p&gt;Total k&lt;sub&gt;cat&lt;/sub&gt; values&lt;/p&gt;\n                    &lt;/div&gt;\n                    &lt;div class=\"stat-box\"&gt;\n                        &lt;h3&gt;{rxn_covered}&lt;/h3&gt;\n                        &lt;p&gt;k&lt;sub&gt;cat&lt;/sub&gt; to be predicted ({rxn_coverage:.2f}%)&lt;/p&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n\n            &lt;!-- Prediction kcat Table --&gt;\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;k&lt;sub&gt;cat&lt;/sub&gt; Prediction Statistics&lt;/h2&gt;\n                &lt;table&gt;\n                    &lt;tr&gt;\n                        &lt;th&gt;Metric&lt;/th&gt;\n                        &lt;th&gt;Value&lt;/th&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Total of entries in CataPro input file&lt;/td&gt;\n                        &lt;td&gt;{total_catapro_entries}&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Number of cofactor identified&lt;/td&gt;\n                        &lt;td&gt;{cofactors_covered}&lt;/td&gt;\n                    &lt;/tr&gt;\n                &lt;/table&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Issues in k&lt;sub&gt;cat&lt;/sub&gt; Predictions&lt;/h2&gt;\n                &lt;table&gt;\n                    &lt;tr&gt;\n                        &lt;th&gt;Metric&lt;/th&gt;\n                        &lt;th&gt;Value&lt;/th&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Entries with no catalytic enzyme identified&lt;/td&gt;\n                        &lt;td&gt;{no_catalytic}&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Entries with missing KEGG IDs&lt;/td&gt;\n                        &lt;td&gt;{kegg_missing}&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Entries with missing enzyme information&lt;/td&gt;\n                        &lt;td&gt;{missing_enzyme}&lt;/td&gt;\n                    &lt;/tr&gt;\n                &lt;/table&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Duplicates&lt;/h2&gt;\n                &lt;table&gt;\n                    &lt;tr&gt;\n                        &lt;th&gt;Metric&lt;/th&gt;\n                        &lt;th&gt;Value&lt;/th&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Number of duplicates&lt;/td&gt;\n                        &lt;td&gt;{duplicates}&lt;/td&gt;\n                    &lt;/tr&gt;\n                &lt;/table&gt;\n                &lt;p&gt;\n                    Duplicates occur when multiple reactions share the same enzyme-substrate combination. \n                    A high number of duplicates may result from multiple enzyme complexes sharing the same catalytic enzyme.\n                &lt;/p&gt;\n            &lt;/div&gt;\n\n            &lt;!-- Prediction Instructions --&gt;\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Running k&lt;sub&gt;cat&lt;/sub&gt; Predictions with CataPro&lt;/h2&gt;\n                &lt;p&gt;\n                    This report provides the input needed to run the CataPro machine learning model \n                    (&lt;a href=\"https://github.com/zchwang/CataPro\" target=\"_blank\"&gt;CataPro repository&lt;/a&gt;). \n                    Follow the instructions in the repository to set up the environment and generate k&lt;sub&gt;cat&lt;/sub&gt; predictions.\n                &lt;/p&gt;\n            &lt;/div&gt;\n\n    &lt;footer&gt;WILDkCAT&lt;/footer&gt;\n    \"\"\"\n    if shader:\n        html += report_shader()\n    else: \n        html += report_simple()\n    html += \"\"\"\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    # Save report\n    os.makedirs(os.path.join(output_folder, \"reports\"), exist_ok=True)\n    report_path = os.path.join(output_folder, \"reports/predict_report.html\")\n    with open(report_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(html)\n    logging.info(f\"HTML report saved to '{report_path}'\")\n</code></pre>"},{"location":"reference/#wildkcat.utils.generate_reports.report_retrieval","title":"<code>report_retrieval(df, output_folder, shader=False)</code>","text":"<p>Generate a styled HTML report summarizing the kcat matching results, including kcat value distribution and matching score repartition.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame containing data from the run_retrieval function.</p> required <code>output_folder</code> <code>str</code> <p>Path to the output folder where the report will be saved.</p> required <code>shader</code> <code>bool</code> <p>If True, includes a shader canvas background in the report. Default is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>The function saves the generated HTML report to 'reports/retrieve_kcat_report.html'.</p> Source code in <code>wildkcat/utils/generate_reports.py</code> <pre><code>def report_retrieval(df, output_folder,shader=False) -&gt; None:\n    \"\"\"\n    Generate a styled HTML report summarizing the kcat matching results,\n    including kcat value distribution and matching score repartition.\n\n    Parameters:\n        df (pd.DataFrame): DataFrame containing data from the run_retrieval function.\n        output_folder (str): Path to the output folder where the report will be saved.\n        shader (bool, optional): If True, includes a shader canvas background in the report. Default is False.\n\n    Returns:\n        None: The function saves the generated HTML report to 'reports/retrieve_kcat_report.html'.\n    \"\"\"\n    # Ensure numeric kcat values to avoid TypeError on comparisons\n    kcat_values = pd.to_numeric(df['kcat'], errors='coerce').dropna()\n\n    # Only use scores present in the data\n    present_scores = sorted(df['matching_score'].dropna().unique())\n    score_counts = df['matching_score'].value_counts().reindex(present_scores, fill_value=0)\n    total = len(df) - 1\n    matched = len(kcat_values) - 1\n    match_percent = matched / total * 100 if total else 0\n    score_percent = (score_counts / total * 100).round(2) if total else pd.Series(0, index=present_scores)\n\n    # Distinct colors for each score (up to 12, then cycle)\n    # Gradient colors from green (best score) to red (worst score)\n    distinct_colors = [\n        \"#27ae60\",\n        \"#43b76e\",\n        \"#60c07c\",\n        \"#7cc98a\",\n        \"#98d298\",\n        \"#b5dbb6\",\n        \"#d1e4c4\",\n        \"#f1e9b6\",\n        \"#f7d97c\",\n        \"#f9c74f\",\n        \"#f8961e\",\n        \"#f3722c\",\n        \"#e67e22\",\n        \"#e74c3c\",\n        \"#c0392b\",\n        \"#a93226\",\n        \"#922b21\",\n        \"#7b241c\"\n    ]\n\n    def score_color(score):\n        idx = present_scores.index(score)\n        return distinct_colors[idx % len(distinct_colors)]\n\n    generated_time = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    # Histogram with stacked bars for scores\n    kcat_hist_base64 = \"\"\n    if not kcat_values.empty:\n        min_exp = int(np.floor(np.log10(max(1e-6, kcat_values.min()))))\n        max_exp = int(np.ceil(np.log10(kcat_values.max())))\n        bins = np.logspace(min_exp, max_exp, num=40)\n\n        fig, ax = plt.subplots(figsize=(10, 6))\n\n        # Stacked histogram by score\n\n        hist_data = [pd.to_numeric(df[df['matching_score'] == score]['kcat'], errors='coerce').dropna() for score in present_scores]\n        ax.hist(hist_data, bins=bins, stacked=True, \n                color=[score_color(s) for s in present_scores], label=[f\"Score {s}\" for s in present_scores], edgecolor='white')\n\n        ax.set_xscale('log')\n        ax.set_xlim([10**min_exp / 1.5, 10**max_exp * 1.5])\n        ax.xaxis.set_major_formatter(LogFormatter(10))\n\n        ax.set_xlabel(\"kcat (s\u207b\u00b9)\", fontsize=12)\n        ax.set_ylabel(\"Count\", fontsize=12)\n        ax.set_title(f\"\", fontsize=13)\n        ax.legend(title=\"Matching Score\", fontsize=12)\n\n        plt.tight_layout()\n        buf = io.BytesIO()\n        plt.savefig(buf, format='png', bbox_inches='tight')\n        plt.close(fig)\n        kcat_hist_base64 = base64.b64encode(buf.getvalue()).decode('utf-8')\n\n    # HTML start\n    html = f\"\"\"\n    &lt;!DOCTYPE html&gt;\n    &lt;html lang=\"en\"&gt;\n    &lt;head&gt;\n        &lt;meta charset=\"UTF-8\"&gt;\n        &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n        &lt;title&gt;Retrieve kcat Report&lt;/title&gt;\n        {report_style()}\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;header&gt;\n            &lt;canvas id=\"shader-canvas\"&gt;&lt;/canvas&gt;\n            &lt;div class=\"overlay\"&gt;\n                &lt;h1&gt;Retrieve k&lt;sub&gt;cat&lt;/sub&gt; Report&lt;/h1&gt;\n                &lt;p&gt;Generated on {generated_time}&lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/header&gt;\n\n        &lt;div class=\"container\"&gt;\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Overview&lt;/h2&gt;\n                &lt;div class=\"stats-grid\"&gt;\n                    &lt;div class=\"stat-box\"&gt;\n                        &lt;h3&gt;{total}&lt;/h3&gt;\n                        &lt;p&gt;Total Entries&lt;/p&gt;\n                    &lt;/div&gt;\n                    &lt;div class=\"stat-box\"&gt;\n                        &lt;h3&gt;{matched}&lt;/h3&gt;\n                        &lt;p&gt;Matched k&lt;sub&gt;cat&lt;/sub&gt; ({match_percent:.2f}%)&lt;/p&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Matching Score Distribution&lt;/h2&gt;\n                &lt;div class=\"progress-stacked\"&gt;\n    \"\"\"\n\n    # Add progress bars only for present scores\n    for score in present_scores:\n        percent = score_percent.get(score, 0)\n        if percent &gt; 0:\n            html += f'&lt;div class=\"progress-bar\" style=\"width:{percent}%;background:{score_color(score)};\" title=\"Score {score}: {percent:.2f}%\"&gt;&lt;/div&gt;'\n\n    html += \"\"\"\n            &lt;/div&gt;\n            &lt;div class=\"legend\"&gt;\n    \"\"\"\n\n    # Add legend only for present scores\n    for score in present_scores:\n        html += f'&lt;div class=\"legend-item\"&gt;&lt;div class=\"legend-color\" style=\"background:{score_color(score)};\"&gt;&lt;/div&gt; Score {score}&lt;/div&gt;'\n\n    html += \"\"\"\n            &lt;/div&gt;\n            &lt;table&gt;\n                &lt;tr&gt;\n                    &lt;th&gt;Score&lt;/th&gt;\n                    &lt;th&gt;Count&lt;/th&gt;\n                    &lt;th&gt;Percent&lt;/th&gt;\n                &lt;/tr&gt;\n    \"\"\"\n\n    # Table rows only for present scores\n    for score in present_scores:\n        html += f'&lt;tr&gt;&lt;td&gt;{score}&lt;/td&gt;&lt;td&gt;{score_counts[score]}&lt;/td&gt;&lt;td&gt;{score_percent[score]:.2f}%&lt;/td&gt;&lt;/tr&gt;'\n\n    html += \"\"\"\n            &lt;/table&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    # Histogram section (stacked by score)\n    html += \"\"\"\n        &lt;div class=\"card\"&gt;\n            &lt;h2&gt;Distribution of k&lt;sub&gt;cat&lt;/sub&gt; values (Stacked by Matching Score)&lt;/h2&gt;\n            &lt;div class=\"img-section\"&gt;\n    \"\"\"\n    if kcat_hist_base64:\n        html += f'&lt;img src=\"data:image/png;base64,{kcat_hist_base64}\" alt=\"k&lt;sub&gt;cat&lt;/sub&gt; Distribution\"&gt;'\n    html += \"\"\"\n            &lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    # Metadata section\n    html += f\"\"\"\n            &lt;div class=\"card\"&gt;\n                &lt;h2&gt;Matching Score&lt;/h2&gt;\n                &lt;p&gt;\n                    The matching score evaluates how well a candidate k&lt;sub&gt;cat&lt;/sub&gt; entry fits the query enzyme and conditions. \n                    A lower score indicates a better match (0 = best possible, 15 = no match).\n                &lt;/p&gt;\n                &lt;h3&gt;Scoring process:&lt;/h3&gt;\n                &lt;ul&gt;\n                    &lt;li&gt;&lt;b&gt;Catalytic enzyme:&lt;/b&gt; Check if the reported enzyme matches the expected catalytic enzyme(s).&lt;/li&gt;\n                    &lt;li&gt;&lt;b&gt;Organism:&lt;/b&gt; Penalize mismatches between the source organism and the target organism.&lt;/li&gt;\n                    &lt;li&gt;&lt;b&gt;Enzyme variant:&lt;/b&gt; Exclude or penalize mutant/engineered variants (wildtype preferred).&lt;/li&gt;\n                    &lt;li&gt;&lt;b&gt;pH:&lt;/b&gt; Check whether the reported pH is consistent with the desired experimental range.&lt;/li&gt;\n                    &lt;li&gt;&lt;b&gt;Substrate:&lt;/b&gt; Verify substrate compatibility with the catalytic reaction.&lt;/li&gt;\n                    &lt;li&gt;&lt;b&gt;Temperature:&lt;/b&gt; Penalize deviations from the target temperature; \n                        if possible, adjust kcat values using the Arrhenius equation.&lt;/li&gt;\n                &lt;/ul&gt;\n\n                &lt;h3&gt;Score breakdown (default penalties):&lt;/h3&gt;\n                &lt;table border=\"1\" cellpadding=\"6\" cellspacing=\"0\" style=\"border-collapse: collapse; text-align: left;\"&gt;\n                    &lt;tr&gt;\n                        &lt;th&gt;Criterion&lt;/th&gt;\n                        &lt;th&gt;Penalty&lt;/th&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Substrate mismatch&lt;/td&gt;\n                        &lt;td&gt;+3&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Catalytic enzyme mismatch&lt;/td&gt;\n                        &lt;td&gt;+2&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Organism mismatch&lt;/td&gt;\n                        &lt;td&gt;+2&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;pH unknown&lt;/td&gt;\n                        &lt;td&gt;+1&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;pH out of range&lt;/td&gt;\n                        &lt;td&gt;+2&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Temperature unknown&lt;/td&gt;\n                        &lt;td&gt;+1&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Temperature out of range&lt;/td&gt;\n                        &lt;td&gt;+2&lt;/td&gt;\n                    &lt;/tr&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;Enzyme variant unknown&lt;/td&gt;\n                        &lt;td&gt;+1&lt;/td&gt;\n                    &lt;/tr&gt;\n                &lt;/table&gt;\n\n                &lt;p&gt;\n                    Candidates are then ranked by:\n                    &lt;ol&gt;\n                        &lt;li&gt;Lowest total score&lt;/li&gt;\n                        &lt;li&gt;Highest sequence identity percentage to the target enzyme&lt;/li&gt;\n                        &lt;li&gt;Closest organism compared to the target organism.&lt;/li&gt;\n                        &lt;li&gt;Adjusted k&lt;sub&gt;cat&lt;/sub&gt; value (favoring the highest value by default)&lt;/li&gt;\n                    &lt;/ol&gt;\n                &lt;/p&gt;\n                &lt;p&gt;\n                    The best candidate is the one with the lowest score after these checks. \n                    If multiple candidates tie on score, sequence identity (or organism if sequence is not available) and k&lt;sub&gt;cat&lt;/sub&gt; values break the tie.\n                &lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;footer&gt;WILDkCAT&lt;/footer&gt;\n    \"\"\"\n    if shader: \n        html += report_shader()\n    else: \n        html += report_simple()\n    html += \"\"\"\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    # Save HTML\n    os.makedirs(os.path.join(output_folder, \"reports\"), exist_ok=True)\n    report_path = os.path.join(output_folder, \"reports/retrieve_report.html\")\n    with open(report_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(html)\n\n    logging.info(f\"HTML report saved to '{report_path}'\")\n</code></pre>"},{"location":"reference/#wildkcat.utils.generate_reports.report_shader","title":"<code>report_shader()</code>","text":"<p>Return HTML and GLSL shader code for report background. Adapted from localthunk (https://localthunk.com)</p> Source code in <code>wildkcat/utils/generate_reports.py</code> <pre><code>def report_shader(): \n    \"\"\"Return HTML and GLSL shader code for report background. Adapted from localthunk (https://localthunk.com)\"\"\"\n    return \"\"\"\n    &lt;!-- Background adapted from original work by localthunk (https://localthunk.com) --&gt;\n    &lt;script id=\"fragShader\" type=\"x-shader/x-fragment\"&gt;\n    precision highp float;\n    uniform vec2 iResolution;\n    uniform float iTime;\n    #define SPIN_ROTATION -1.0\n    #define SPIN_SPEED 3.5\n    #define OFFSET vec2(0.0)\n    #define COLOUR_1 vec4(0.2, 0.4, 0.7, 1.0)\n    #define COLOUR_2 vec4(0.6, 0.75, 0.9, 1.0)\n    #define COLOUR_3 vec4(0.2, 0.2, 0.25, 1.0)\n    #define CONTRAST 3.5\n    #define LIGTHING 0.4\n    #define SPIN_AMOUNT 0.25\n    #define PIXEL_FILTER 745.0\n    #define SPIN_EASE 1.0\n    #define PI 3.14159265359\n    #define IS_ROTATE false\n    vec4 effect(vec2 screenSize, vec2 screen_coords) {\n        float pixel_size = length(screenSize.xy) / PIXEL_FILTER;\n        vec2 uv = (floor(screen_coords.xy*(1./pixel_size))*pixel_size - 0.5*screenSize.xy)/length(screenSize.xy) - OFFSET;\n        float uv_len = length(uv);\n        float speed = (SPIN_ROTATION*SPIN_EASE*0.2);\n        if(IS_ROTATE) {\n        speed = iTime * speed;\n        }\n        speed += 302.2;\n        float new_pixel_angle = atan(uv.y, uv.x) + speed - SPIN_EASE*20.*(1.*SPIN_AMOUNT*uv_len + (1. - 1.*SPIN_AMOUNT));\n        vec2 mid = (screenSize.xy/length(screenSize.xy))/2.;\n        uv = (vec2((uv_len * cos(new_pixel_angle) + mid.x), (uv_len * sin(new_pixel_angle) + mid.y)) - mid);\n        uv *= 30.;\n        speed = iTime*(SPIN_SPEED);\n        vec2 uv2 = vec2(uv.x+uv.y);\n        for(int i=0; i &lt; 5; i++) {\n            uv2 += sin(max(uv.x, uv.y)) + uv;\n            uv  += 0.5*vec2(cos(5.1123314 + 0.353*uv2.y + speed*0.131121),sin(uv2.x - 0.113*speed));\n            uv  -= 1.0*cos(uv.x + uv.y) - 1.0*sin(uv.x*0.711 - uv.y);\n        }\n        float contrast_mod = (0.25*CONTRAST + 0.5*SPIN_AMOUNT + 1.2);\n        float paint_res = min(2., max(0.,length(uv)*(0.035)*contrast_mod));\n        float c1p = max(0.,1. - contrast_mod*abs(1.-paint_res));\n        float c2p = max(0.,1. - contrast_mod*abs(paint_res));\n        float c3p = 1. - min(1., c1p + c2p);\n        float light = (LIGTHING - 0.2)*max(c1p*5. - 4., 0.) + LIGTHING*max(c2p*5. - 4., 0.);\n        return (0.3/CONTRAST)*COLOUR_1 + (1. - 0.3/CONTRAST)*(COLOUR_1*c1p + COLOUR_2*c2p + vec4(c3p*COLOUR_3.rgb, c3p*COLOUR_1.a)) + light;\n    }\n    void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        vec2 uv = fragCoord/iResolution.xy;\n        fragColor = effect(iResolution.xy, uv * iResolution.xy);\n    }\n    void main() { mainImage(gl_FragColor, gl_FragCoord.xy); }\n    &lt;/script&gt;\n    &lt;script&gt;\n    const canvas = document.getElementById(\"shader-canvas\");\n    const gl = canvas.getContext(\"webgl\");\n    function resize() {\n        canvas.width = canvas.clientWidth * window.devicePixelRatio;\n        canvas.height = canvas.clientHeight * window.devicePixelRatio;\n        gl.viewport(0, 0, canvas.width, canvas.height);\n    }\n    window.addEventListener(\"resize\", resize);\n    resize();\n    const vertexSrc = `\n    attribute vec2 position;\n    void main() {\n        gl_Position = vec4(position, 0.0, 1.0);\n    }\n    `;\n    const fragSrc = document.getElementById(\"fragShader\").text;\n    function compileShader(src, type) {\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(gl.getShaderInfoLog(shader));\n    }\n    return shader;\n    }\n    const vertexShader = compileShader(vertexSrc, gl.VERTEX_SHADER);\n    const fragmentShader = compileShader(fragSrc, gl.FRAGMENT_SHADER);\n    const program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    gl.useProgram(program);\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n    -1, -1, 1, -1, -1, 1,\n    -1, 1, 1, -1, 1, 1\n    ]), gl.STATIC_DRAW);\n    const positionLoc = gl.getAttribLocation(program, \"position\");\n    gl.enableVertexAttribArray(positionLoc);\n    gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);\n    const iResolutionLoc = gl.getUniformLocation(program, \"iResolution\");\n    const iTimeLoc = gl.getUniformLocation(program, \"iTime\");\n    function render(time) {\n    resize();\n    gl.uniform2f(iResolutionLoc, canvas.width, canvas.height);\n    gl.uniform1f(iTimeLoc, time * 0.001);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    requestAnimationFrame(render);\n    }\n    requestAnimationFrame(render);\n    &lt;/script&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/#wildkcat.utils.generate_reports.report_simple","title":"<code>report_simple()</code>","text":"<p>Return HTML code for report background.</p> Source code in <code>wildkcat/utils/generate_reports.py</code> <pre><code>def report_simple():\n    \"\"\"Return HTML code for report background.\"\"\"\n    return \"\"\"\n    &lt;style&gt;\n        header {\n            background-color: #2980b9; /* simple blue background */\n            margin: 0;\n            padding: 0;\n        }\n    &lt;/style&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/#wildkcat.utils.generate_reports.report_style","title":"<code>report_style()</code>","text":"<p>Return CSS script for report style.</p> Source code in <code>wildkcat/utils/generate_reports.py</code> <pre><code>def report_style():\n    \"\"\"Return CSS script for report style.\"\"\"\n    return \"\"\"\n    &lt;style&gt;\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background-color: #f4f6f9;\n            margin: 0;\n            padding: 0;\n            color: #333;\n        }\n        header {\n            position: relative;\n            width: 100%;\n            height: 150px;\n            overflow: hidden;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            color: #fff;\n            text-align: center;\n        }\n        header canvas {\n            position: absolute;\n            top: 0; left: 0;\n            width: 100%;\n            height: 100%;\n            z-index: 0;\n        }\n        header::before {\n            content: \"\";\n            position: absolute;\n            top: 0; left: 0; right: 0; bottom: 0;\n            background: linear-gradient(\n                rgba(0,0,0,0.5),\n                rgba(0,0,0,0.3)\n            );\n            z-index: 1;\n        }\n        header .overlay {\n            position: relative;\n            z-index: 2;\n            padding: 10px 20px;\n            border-radius: 8px;\n        }\n        header h1 {\n            margin: 0;\n            font-size: 2.5rem;\n            font-weight: bold;\n            text-shadow: 0 2px 6px rgba(0,0,0,0.6);\n        }\n        header p {\n            margin: 8px 0 0;\n            font-size: 1.1rem;\n            text-shadow: 0 1px 4px rgba(0,0,0,0.6);\n        }\n        .container {\n            max-width: 1100px;\n            margin: 30px auto;\n            padding: 20px;\n        }\n        .card {\n            background: #fff;\n            border-radius: 12px;\n            padding: 20px;\n            margin-bottom: 20px;\n            box-shadow: 0 2px 8px rgba(0,0,0,0.05);\n        }\n        .card h2 {\n            margin-top: 0;\n            color: #2980b9;\n            border-bottom: 2px solid #e6e6e6;\n            padding-bottom: 10px;\n            font-size: 1.5rem;\n        }\n        .stats-grid {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n            gap: 15px;\n            margin-top: 15px;\n        }\n        .stat-box {\n            background: #f9fafc;\n            border-radius: 8px;\n            padding: 15px;\n            text-align: center;\n            border: 1px solid #e2e2e2;\n        }\n        table {\n            width: 100%;\n            border-collapse: collapse;\n            margin-top: 20px;\n            font-size: 0.95rem;\n        }\n        table th, table td {\n            border: 1px solid #ddd;\n            padding: 10px;\n            text-align: left;\n        }\n        table th {\n            background-color: #2980b9;\n            color: #fff;\n        }\n        table tr:nth-child(even) {\n            background-color: #f2f2f2;\n        }\n        .progress {\n            background-color: #ddd;\n            border-radius: 10px;\n            overflow: hidden;\n            height: 18px;\n            width: 100%;\n            margin-top: 5px;\n        }\n        .progress-stacked {\n            display: flex;\n            height: 18px;\n            border-radius: 10px;\n            overflow: hidden;\n            background-color: #ddd;\n            font-size: 0.75rem;\n            line-height: 18px;\n            color: white;\n            text-shadow: 0 1px 1px rgba(0,0,0,0.2);\n            margin-bottom: 10px;\n        }\n        .progress-bar {\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            height: 100%;\n            white-space: nowrap;\n            overflow: hidden;\n        }\n        .progress-bar-table {\n            background-color: #27ae60;\n            height: 100%;\n            text-align: right;\n            padding-right: 5px;\n            color: white;\n            font-size: 0.8rem;\n            line-height: 18px;\n        }\n        .progress-multi {\n            display: flex;\n            width: 100%;\n            height: 25px;\n            border-radius: 12px;\n            overflow: hidden;\n            border: 1px solid #ccc;\n        }\n        .progress-segment {\n            height: 100%;\n        }\n        .legend {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 10px;\n            font-size: 0.85rem;\n            margin-top: 5px;\n        }\n        .legend-item {\n            display: flex;\n            align-items: center;\n            gap: 5px;\n        }\n        .legend-color {\n            width: 14px;\n            height: 14px;\n            border-radius: 3px;\n            border: 1px solid #aaa;\n        }\n        .img-section {\n            display: flex;\n            flex-wrap: wrap;\n            gap: 30px;\n            justify-content: center;\n            align-items: flex-start;\n            margin-top: 20px;\n        }\n        footer {\n            text-align: center;\n            font-size: 0.9rem;\n            color: #777;\n            padding: 15px;\n            margin-top: 20px;\n            border-top: 1px solid #ddd;\n        }\n    &lt;/style&gt;\n    \"\"\"\n</code></pre>"},{"location":"explanation/explanation/","title":"Explanation of the WILDkCAT Pipeline","text":""},{"location":"explanation/explanation/#workflow-overview","title":"Workflow Overview","text":""},{"location":"explanation/explanation/#1-extract-kcat-values-from-a-metabolic-model","title":"1 - Extract kcat values from a metabolic model","text":"<p>The first step involves extracting potential kcat values from a given metabolic model. </p> <p>The output is a TSV file where each row corresponds to a unique combination of reaction, enzyme, and substrate(s). This file serves as the basis for retrieving experimental kcat values from BRENDA and SABIO-RK databases.</p>"},{"location":"explanation/explanation/#details-of-the-extraction-process","title":"Details of the extraction process","text":"<p>During this step, several verification procedures are carried out to ensure consistency between the model annotations and external databases:</p> <ol> <li> <p>Fields checked during extraction</p> <ul> <li>Reaction identifiers: <code>model.reaction[i].annotation.get('kegg.reaction')</code></li> <li>EC numbers: <code>model.reaction[i].annotation.get('ec-code')</code></li> <li>Compounds: <code>model.metabolites[i].annotation.get('kegg.compound')</code></li> <li>Genes: <code>model.genes[i].annotation.get('uniprot')</code></li> </ul> </li> <li> <p>Verification of EC numbers via KEGG</p> <p>Each EC number associated with a reaction is checked using the KEGG API. This ensures that the EC number is still valid, or if it has been transferred. </p> </li> <li> <p>Handling enzyme complexes (multiple enzymes per reaction)</p> <ul> <li> <p>When a reaction is associated with multiple enzymes (enzyme complex), the UniProt API is queried to identify which subunit is the catalytic enzyme.</p> </li> <li> <p>A dedicated column (<code>warning</code>) is used to flag potential issues:</p> <ul> <li><code>none</code>: no catalytic enzyme identified.</li> <li><code>multiple</code>: more than one possible catalytic enzyme identified.</li> <li>(empty): one clear catalytic enzyme has been identified.</li> </ul> </li> </ul> </li> </ol>"},{"location":"explanation/explanation/#2-retrieve-experimental-kcat-values-from-brenda-andor-sabio-rk","title":"2 - Retrieve experimental kcat values from BRENDA and/or SABIO-RK","text":"<p>In this step, experimental kcat values are retrieved from the BRENDA and SABIO-RK databases.</p> <p>If no exact value is available, the pipeline assigns the closest possible match using a penalty-based scoring system.</p>"},{"location":"explanation/explanation/#matching-score","title":"Matching score","text":"<p>The matching score evaluates how well a candidate kcat entry fits the query enzyme and conditions.</p> <ul> <li>A lower score indicates a better match.</li> <li><code>0</code> = best possible match (perfect fit).</li> <li><code>15</code> = no reliable match.</li> </ul>"},{"location":"explanation/explanation/#penalty-based-scoring-system","title":"Penalty-based scoring system","text":"<p>Warning</p> <p>Penalty values are preliminary and not final. The penalty system will be developed in collaboration with an expert in the field and can also be modified if necessary.</p> <p>Each criterion adds a penalty if the candidate entry deviates from the query:</p> Criterion Description Penalty Organism Same organism 0 Different or unknown 2 Substrate Same substrate 0 Different or unknown 3 Catalytic enzyme Matches expected enzyme 0 Does not match or unknown 2 Variant Wild-type 0 Unknown 1 Mutant 14 Temperature Within specified range 0 Corrected via Arrhenius equation 0 Unknown 1 Outside specified range 2 pH Within specified range 0 Unknown 1 Outside specified range 2"},{"location":"explanation/explanation/#details-of-the-retrieval-process","title":"Details of the retrieval process","text":"<ol> <li> <p>Database querying</p> <p>The BRENDA and/or SABIO-RK databases are queried using their respective APIs. Queries are performed based on EC numbers.</p> </li> <li> <p>Tie-Breaking Strategy</p> <p>When multiple kcat entries share the same matching score, the following criteria are applied sequentially to select the most appropriate value:</p> <ul> <li> <p>Sequence Identity: Align the enzyme sequences using BioPython\u2019s <code>Align.PairwiseAligner()</code> and prioritize higher sequence identity.</p> </li> <li> <p>Organism Proximity: Use <code>Entrez.efetch()</code> to determine the organism closest to the target species.</p> </li> <li> <p>Maximal kcat Selection: If ties remain, select the entry with the highest kcat value, thus avoiding excessively stringent constraints on the model.</p> </li> </ul> </li> <li> <p>Correction of the kcat value using the Arrhenius equation</p> <p>If the temperature at which kcat was measured is outside the desired range and at least two kcat measurements are available (to estimate \\( E_a \\)), the kcat value can be adjusted using the Arrhenius equation:</p> \\[ kcat_{\\text{opt}} = kcat_{\\text{db}} \\times \\exp\\left(-\\frac{E_a}{R} \\left(\\frac{1}{T_{\\text{db}}} - \\frac{1}{T_{\\text{opt}}}\\right)\\right) \\] <p>Where:</p> <ul> <li>\\( E_a \\) = Activation energy</li> <li>\\( R \\) = Universal gas constant (8.314 J/(mol\u00b7K))</li> <li>\\( T_{db} \\) = Temperature at which kcat was measured (in Kelvin)</li> <li>\\( T_{opt} \\) = Temperature range midpoint (in Kelvin)</li> </ul> <p>Notes: </p> <ul> <li>The target temperature \\( T_{opt} \\) corresponds to the midpoint of the desired optimal range.</li> </ul> </li> <li> <p>Merging rows with same reaction-enzyme combination</p> <p>During the extraction step, multiple rows may be generated if a combination of reaction and enzyme is associated with multiple EC numbers. In such cases, after the retrieval step, these rows are merged to retain only the best kcat value. The column <code>ec_codes</code> lists all the EC numbers associated with the reaction-enzyme pair. The column <code>ec-code</code> indicates the EC number corresponding to the selected kcat value.</p> </li> </ol>"},{"location":"explanation/explanation/#3-predict-missing-kcat-values-using-machine-learning","title":"3 - Predict missing kcat values using machine learning","text":"<p>When no suitable experimental kcat value is found, the pipeline allows the prediction of kcat values using the CataPro machine learning model. The predictions rely on reaction substrates (SMILES) and enzyme sequences. </p> <p>Predicted kcat values are used to replace experimental values that fall below a threshold, defined by the <code>limit_matching_score</code> argument. If a kcat value cannot be predicted, the best available experimental kcat value is retained.</p> <p>If multiple substrates are involved in the reaction, the prediction is performed for each substrate, and the lowest predicted kcat value is retained.</p>"},{"location":"explanation/explanation/#details-of-the-prediction-process","title":"Details of the prediction process","text":"<ol> <li> <p>Identification of the enzyme sequence</p> <p>The UniProt API is queried to retrieve the amino acid sequence of the catalytic enzyme from the UniProt ID.</p> </li> <li> <p>Cofactor Identification</p> <p>The BRENDA API is queried to identify cofactors associated with the reaction. If no cofactors are found, the kcat prediction is performed for all the metabolites involved in the reaction, then the lowest predicted kcat value is retained.</p> </li> <li> <p>Substrate SMILES Retrieval</p> <p>The PubChem API is queried to retrieve the SMILES representation of each substrate from their KEGG IDs.</p> </li> </ol>"},{"location":"tutorial/tutorials/","title":"Example on E. coli Core Model","text":"<p>This page shows a step-by-step example of the WILDkCAT pipeline on the E. coli core model.</p> <p>Info</p> <p>The parameter <code>output_folder</code> specifies the directory where all files generated by the pipeline will be stored. The purpose of this design is to centralize all results in a single location, with files being added progressively as each step is executed.  </p>"},{"location":"tutorial/tutorials/#prerequisites-cf-installation-instructions","title":"Prerequisites (cf. installation instructions)","text":"<ul> <li>Install WILDkCAT from PyPI</li> <li>Install CataPro to predict kcat values using machine learning</li> <li>Download the E. coli core model</li> </ul> <pre><code>mkdir model\ncurl -O model/e_coli_core.json http://bigg.ucsd.edu/static/models/e_coli_core.json\n</code></pre> <p>Your working directory should contain the following folders:</p> <ul> <li><code>venv/</code> - Folder containing the Python virtual environment</li> <li><code>CataPro/</code> - Folder containing the CataPro repository</li> <li><code>model/</code> - Folder containing the E. coli core model (e_coli_core.json)</li> </ul> <p>Note</p> <p>All the files used and created in this tutorial are available in the output folder of the WILDkCAT repository</p>"},{"location":"tutorial/tutorials/#1-extract-kcat-values-from-e-coli-core-model","title":"1 \u2014 Extract kcat values from E. coli core model","text":"<p>Time: ~3-4 min </p> <p>First, for each combination of reaction, enzyme, and substrate(s) in the model, create a TSV file. </p> <p>Each row corresponds to a unique combination of reaction, enzyme, and substrate(s) and will be used to retrieve experimental kcat values from BRENDA and SABIO-RK in the next step. The output file is named <code>kcat.tsv</code> and is saved in the specified output folder.</p> Programmatic AccessCommand Line Interface (CLI) <pre><code>from wildkcat import run_extraction\n\nrun_extraction(\n    model_path=\"model/e_coli_core.json\",\n    output_folder=\"output\"\n)\n</code></pre> <pre><code>wildkcat extraction model/e_coli_core.json output\n</code></pre> <p>Example of the output file <code>kcat.tsv</code>:</p> rxn rxn_kegg ec_code ec_codes direction substrates_name substrates_kegg products_name products_kegg genes uniprot catalytic_enzyme warning PFK 2.7.1.11 2.7.1.11 forward ATP C10H12N5O13P3;D-Fructose 6-phosphate C00002;C05345 ADP C10H12N5O10P2;D-Fructose 1,6-bisphosphate;H+ C00008;C00354;C00080 b3916 P0A796 P0A796 ACALD R00228 1.2.1.10 1.2.1.10 reverse Acetyl-CoA;H+;Nicotinamide adenine dinucleotide - reduced C00024;C00080;C00004 Acetaldehyde;Coenzyme A;Nicotinamide adenine dinucleotide C00084;C00010;C00003 b1241 P0A9Q7 P0A9Q7 <p>View the generated report</p>"},{"location":"tutorial/tutorials/#2-retrieve-experimental-kcat-values-from-brenda-andor-sabio-rk","title":"2 \u2014 Retrieve experimental kcat values from BRENDA and/or SABIO-RK","text":"<p>Time: ~7-10 min</p> <p>This function searches for experimentally measured turnover numbers (kcat values) in the BRENDA and/or SABIO-RK databases for the kcats listed in the input file.  The retrieved values are filtered based on organism, temperature, and pH conditions. The closest matching kcat values are saved to the output file.</p> Programmatic AccessCommand Line Interface (CLI) <pre><code>from wildkcat import run_retrieval\n\nrun_retrieval(\n    output_folder=\"output\",\n    organism=\"Escherichia coli\",\n    temperature_range=(20, 40),\n    pH_range=(6.5, 7.5),\n    database='both'\n    )\n</code></pre> <pre><code>wildkcat retrieval output 'Escherichia coli' 20 40 6.5 7.5\n</code></pre> <p>Example of the output file <code>kcat_retrieved.tsv</code>:</p> rxn rxn_kegg ec_code ec_codes direction substrates_name substrates_kegg products_name products_kegg genes uniprot catalytic_enzyme warning kcat matching_score kcat_substrate kcat_organism kcat_enzyme kcat_temperature kcat_ph kcat_variant kcat_db kcat_id_percent kcat_organism_score PFK 2.7.1.11 2.7.1.11 forward ATP C10H12N5O13P3;D-Fructose 6-phosphate C00002;C05345 ADP C10H12N5O10P2;D-Fructose 1,6-bisphosphate;H+ C00008;C00354;C00080 b3916 P0A796 P0A796 88.0 1 fructose 6-phosphate Escherichia coli P0A796 30.0 7.2 brenda 100.0 0.0 ACALD R00228 1.2.1.10 1.2.1.10 reverse Acetyl-CoA;H+;Nicotinamide adenine dinucleotide - reduced C00024;C00080;C00004 Acetaldehyde;Coenzyme A;Nicotinamide adenine dinucleotide C00084;C00010;C00003 b1241 P0A9Q7 P0A9Q7 15.7 8 acetaldehyde Escherichia coli 25 8.0 brenda 0.0 <p>View the generated report</p> <p>Note</p> <p>BRENDA requires a user account to access its data. In contrast, SABIO-RK is openly accessible and does not require registration. If you want to only use SABIO-RK, set the parameter <code>database='sabio_rk'</code> in the function or use the flag <code>--database sabio_rk</code> in the CLI command.</p>"},{"location":"tutorial/tutorials/#3-predict-missing-kcat-values-using-machine-learning","title":"3 \u2014 Predict missing kcat values using machine learning","text":""},{"location":"tutorial/tutorials/#31-prepare-input-file-for-catapro","title":"3.1 - Prepare input file for CataPro","text":"<p>Prepare the input file for CataPro by filtering out the kcat entries that were not found in the previous step and below a limit score (<code>limit_matching_score</code>). The resulting file will be used to predict missing kcat values using machine learning.</p> <p>The function generates the files named <code>catapro_input.csv</code> and <code>catapro_input_substrates_to_smiles.tsv</code> in the subfolder <code>machine_learning</code>. </p> <p>Note</p> <p>The file <code>catapro_input_substrates_to_smiles.tsv</code> that maps substrate names to their corresponding SMILES will be used to match back the predicted kcat values to the original kcat entries after running CataPro.</p> Programmatic AccessCommand Line Interface (CLI) <pre><code>from wildkcat import run_prediction_part1\n\nrun_prediction_part1(\n    output_folder=\"output\",\n    limit_matching_score=6\n    )\n</code></pre> <pre><code>wildkcat prediction-part1 output 6\n</code></pre> <p>The output file <code>catapro_input.csv</code> is formatted according to the requirements of CataPro, meaning it can be directly used as input for kcat prediction.</p> <p>Note</p> <p>Before running predictions, make sure you have installed CataPro by following the installation instructions provided in their GitHub repository.</p> <p>Once installed, you can run CataPro with the following command:</p> <pre><code>python CataPro.predict.py \\\n        -inp_fpath output/machine_learning/catapro_input.csv \\\n        -model_dpath models \\\n        -batch_size 64 \\\n        -device cuda:0 \\\n        -out_fpath output/machine_learning/catapro_output.csv\n</code></pre> <p>View the generated report</p>"},{"location":"tutorial/tutorials/#32-integrate-catapro-predictions","title":"3.2 - Integrate CataPro predictions","text":"<p>Time: ~2-5 sec</p> <p>After running CataPro with the prepared input file, integrate the predicted kcat values back into the original kcat entries. The function matches the predicted values to the original entries using the substrate names and SMILES mapping file generated in the previous step.</p> Programmatic AccessCommand Line Interface (CLI) <pre><code>from wildkcat import run_prediction_part2\n\nrun_prediction_part2(\n    output_folder=\"output\", \n    catapro_predictions_path=\"output/machine_learning/catapro_output.csv\", \n    limit_matching_score=6\n    )\n</code></pre> <pre><code>wildkcat prediction-part2 output output/machine_learning/catapro_output.csv 6\n</code></pre> <p>Example of the output file <code>kcat_full.tsv</code>:</p> rxn rxn_kegg ec_code ec_codes direction substrates_name substrates_kegg products_name products_kegg genes uniprot catalytic_enzyme warning kcat db matching_score kcat_substrate kcat_organism kcat_enzyme kcat_temperature kcat_ph kcat_variant kcat_id_percent kcat_organism_score PFK 2.7.1.11 2.7.1.11 forward ATP C10H12N5O13P3;D-Fructose 6-phosphate C00002;C05345 ADP C10H12N5O10P2;D-Fructose 1,6-bisphosphate;H+ C00008;C00354;C00080 b3916 P0A796 P0A796 88.0 brenda 1 fructose 6-phosphate Escherichia coli P0A796 30.0 7.2 100.0 0.0 ACALD R00228 1.2.1.10 1.2.1.10 reverse Acetyl-CoA;H+;Nicotinamide adenine dinucleotide - reduced C00024;C00080;C00004 Acetaldehyde;Coenzyme A;Nicotinamide adenine dinucleotide C00084;C00010;C00003 b1241 P0A9Q7 P0A9Q7 20.2328 catapro"},{"location":"tutorial/tutorials/#4-generate-summary-report","title":"4 \u2014 Generate summary report","text":"<p>Time: ~2-5 sec</p> <p>The final output file <code>kcat_full.tsv</code> contains both experimentally retrieved and machine learning predicted kcat values for each combination of reaction, enzyme, and substrate(s) in the E. coli core model. This file can be used for integration into enzyme-constrained metabolic models.</p> <p>The result can be visualized and summarized using the function <code>generate_summary_report</code>: </p> Programmatic AccessCommand Line Interface (CLI) <pre><code>from wildkcat import generate_summary_report\n\ngenerate_summary_report(\n    model_path=\"model/e_coli_core.json\", \n    output_folder=\"output\"\n    )\n</code></pre> <pre><code>wildkcat report model/e_coli_core.json output\n</code></pre> <p>View the generated report</p>"}]}