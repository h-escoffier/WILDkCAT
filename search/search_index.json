{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>WILDkCAT offers a comprehensive range of functions for extracting, retrieving and predicting enzyme kinetic data for a given metabolic model. The tool facilitates enzyme-constrained modelling by assigning specific kcat values to each combination of reaction, enzyme, and substrate(s).</p> <p>WILDkCAT integrates the BRENDA and SABIO-RK APIs to retrieve experimental values and CataPro to predict missing values. It can be used with various enzyme-constrained metabolic modelling methods, such as COBREXA.jl and GECKO, facilitating the seamless integration of kcat values into a given metabolic model.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>Install WILDkCAT directly from PyPI:</p> <pre><code>pip install wildkcat\n</code></pre>"},{"location":"installation/#environment-setup","title":"Environment Setup","text":"<p>Provide your BRENDA login credentials and Entrez API email adress to query the BRENDA enzyme database and NCBI database.</p> <p>Create a file named <code>.env</code> in the root of your project with the following content:</p> <pre><code>ENTREZ_EMAIL=your_registered_email@example.com\nBRENDA_EMAIL=your_registered_email@example.com\nBRENDA_PASSWORD=your_password\n</code></pre> <p>Note</p> <ul> <li>Replace the placeholders with the credentials from the BRENDA website account you created.</li> </ul> <p>Danger</p> <ul> <li>Keep the file <code>.env</code> private (e.g., add it to your <code>.gitignore</code>) as it contains sensitive information.</li> </ul>"},{"location":"reference/","title":"Main functions","text":"<p>The <code>wildkcat</code> package is organized into modules: </p> <ol> <li> <p>Extraction : Extraction of kcat values from the provided model</p> </li> <li> <p>Retrieval : Retrieval of kcat values using curated databases (BRENDA and SABIO-RK)</p> </li> <li> <p>Prediction : Prediction of missing and low confidence kcat values using ML-based CataPro model</p> </li> <li> <p>Summary : Generates an HTML report summarizing the percentage and quality of kcat values identified for the model, along with their data sources.</p> </li> </ol>"},{"location":"reference/#extraction","title":"Extraction","text":""},{"location":"reference/#wildkcat.processing.extract_kcat.run_extraction","title":"<code>wildkcat.processing.extract_kcat.run_extraction(model_path, output_path, report=True)</code>","text":"<p>Extracts kcat-related data from a metabolic model and generates output files and an optional HTML report.</p> <p>Parameters:</p> Name Type Description Default <code>model_path</code> <code>str</code> <p>Path to the metabolic model file (JSON, MATLAB, or SBML format).</p> required <code>output_path</code> <code>str</code> <p>Path to the output file (TSV format).</p> required <code>report</code> <code>bool</code> <p>Whether to generate an HTML report (default: True).</p> <code>True</code> Source code in <code>wildkcat/processing/extract_kcat.py</code> <pre><code>def run_extraction(model_path: str, \n                   output_path: str, \n                   report: bool = True) -&gt; None:\n    \"\"\"\n    Extracts kcat-related data from a metabolic model and generates output files and an optional HTML report.\n\n    Parameters:\n        model_path (str): Path to the metabolic model file (JSON, MATLAB, or SBML format).\n        output_path (str): Path to the output file (TSV format).\n        report (bool, optional): Whether to generate an HTML report (default: True).\n    \"\"\"\n    model = read_model(model_path)\n    df, report_statistics = create_kcat_output(model)\n\n    df.to_csv(output_path, sep='\\t', index=False)\n    logging.info(f\"Output saved to '{output_path}'\")\n    if report:\n        report_extraction(model, df, report_statistics)\n</code></pre>"},{"location":"reference/#retrieval","title":"Retrieval","text":""},{"location":"reference/#wildkcat.processing.retrieve_kcat.run_retrieval","title":"<code>wildkcat.processing.retrieve_kcat.run_retrieval(kcat_file_path, output_path, organism, temperature_range, pH_range, database='both', report=True)</code>","text":"<p>Retrieves closests kcat values from specified databases for entries in a kcat file, applies filtering criteria,  and saves the results to an output file.</p> <p>Parameters:</p> Name Type Description Default <code>kcat_file_path</code> <code>str</code> <p>Path to the input kcat file.</p> required <code>output_path</code> <code>str</code> <p>Path to save the output file with retrieved kcat values.</p> required <code>organism</code> <code>str</code> <p>Organism name.</p> required <code>temperature_range</code> <code>tuple</code> <p>Acceptable temperature range for filtering (min, max).</p> required <code>pH_range</code> <code>tuple</code> <p>Acceptable pH range for filtering (min, max).</p> required <code>database</code> <code>str</code> <p>Specifies which database(s) to query for kcat values.  Options are 'both' (default), 'brenda', or 'sabio_rk'.</p> <code>'both'</code> <code>report</code> <code>bool</code> <p>Whether to generate an HTML report using the retrieved data (default: True).</p> <code>True</code> Source code in <code>wildkcat/processing/retrieve_kcat.py</code> <pre><code>def run_retrieval(kcat_file_path: str,\n                  output_path: str,\n                  organism: str,\n                  temperature_range: tuple,\n                  pH_range: tuple,\n                  database: str = 'both',\n                  report: bool = True) -&gt; None:\n    \"\"\"\n    Retrieves closests kcat values from specified databases for entries in a kcat file, applies filtering criteria, \n    and saves the results to an output file.\n\n    Parameters:\n        kcat_file_path (str): Path to the input kcat file.\n        output_path (str): Path to save the output file with retrieved kcat values.\n        organism (str): Organism name.\n        temperature_range (tuple): Acceptable temperature range for filtering (min, max).\n        pH_range (tuple): Acceptable pH range for filtering (min, max).\n        database (str, optional): Specifies which database(s) to query for kcat values. \n            Options are 'both' (default), 'brenda', or 'sabio_rk'.\n        report (bool, optional): Whether to generate an HTML report using the retrieved data (default: True).        \n    \"\"\"\n    # Create a dict with the general criterias\n    general_criteria = {\n        \"Organism\": organism,\n        \"Temperature\": temperature_range,\n        \"pH\": pH_range\n    }\n\n    # Read the kcat file\n    kcat_df = pd.read_csv(kcat_file_path, sep='\\t')\n\n    # Initialize new columns\n    kcat_df['kcat'] = None\n    kcat_df['matching_score'] = None\n\n    # Add data of the retrieve kcat values\n    kcat_df['catalytic_enzyme'] = None\n    kcat_df['kcat_substrate'] = None\n    kcat_df['kcat_organism'] = None\n    kcat_df['kcat_enzyme'] = None\n    kcat_df['kcat_temperature'] = None\n    kcat_df['kcat_ph'] = None\n    kcat_df['kcat_variant'] = None\n    kcat_df['kcat_db'] = None\n\n    # Retrieve kcat values from databases\n    request_count = 0\n    for row in tqdm(kcat_df.itertuples(), total=len(kcat_df), desc=\"Retrieving kcat values\"):\n        kcat_dict = row._asdict()\n\n        # Extract kcat and matching score\n        best_match, matching_score = extract_kcat(kcat_dict, general_criteria, database=database)\n        kcat_df.loc[row.Index, 'matching_score'] = matching_score\n\n        request_count += 1\n        if request_count % 300 == 0:\n            time.sleep(10)\n\n        if best_match is not None:\n            # Assign results to the main dataframe\n            kcat_df.loc[row.Index, 'kcat'] = best_match['adj_kcat']\n            kcat_df.loc[row.Index, 'catalytic_enzyme'] = best_match['catalytic_enzyme']\n            kcat_df.loc[row.Index, 'kcat_substrate'] = best_match['Substrate']\n            kcat_df.loc[row.Index, 'kcat_organism'] = best_match['Organism']\n            kcat_df.loc[row.Index, 'kcat_enzyme'] = best_match['UniProtKB_AC']\n            kcat_df.loc[row.Index, 'kcat_temperature'] = best_match['adj_temp']\n            kcat_df.loc[row.Index, 'kcat_ph'] = best_match['pH']\n            kcat_df.loc[row.Index, 'kcat_variant'] = best_match['EnzymeVariant']\n            kcat_df.loc[row.Index, 'kcat_db'] = best_match['db']\n            if best_match.get('id_perc') != -1:\n                kcat_df.loc[row.Index, 'kcat_id_percent'] = best_match['id_perc']\n            if best_match.get('organism_score') != np.inf:\n                kcat_df.loc[row.Index, 'kcat_organism_score'] = best_match['organism_score']\n\n    kcat_df.to_csv(output_path, sep='\\t', index=False)\n    logging.info(f\"Output saved to '{output_path}'\")\n\n    if report:\n        report_retrieval(kcat_df)\n</code></pre>"},{"location":"reference/#prediction","title":"Prediction","text":""},{"location":"reference/#wildkcat.processing.predict_kcat.run_prediction_part1","title":"<code>wildkcat.processing.predict_kcat.run_prediction_part1(kcat_file_path, output_path, limit_matching_score, report=True)</code>","text":"<p>Processes kcat data file to generate input files for CataPro prediction. Optionally, it can produce a summary report of the processed data.</p> <p>Parameters:</p> Name Type Description Default <code>kcat_file_path</code> <code>str</code> <p>Path to the input kcat data file.</p> required <code>output_path</code> <code>str</code> <p>Path to save the generated CataPro input CSV file.</p> required <code>limit_matching_score</code> <code>int</code> <p>Threshold for filtering entries based on matching score.</p> required <code>report</code> <code>bool</code> <p>Whether to generate a report using the retrieved data (default: True).</p> <code>True</code> Source code in <code>wildkcat/processing/predict_kcat.py</code> <pre><code>def run_prediction_part1(kcat_file_path: str, \n                         output_path: str, \n                         limit_matching_score: int, \n                         report: bool = True) -&gt; None:\n    \"\"\"\n    Processes kcat data file to generate input files for CataPro prediction.\n    Optionally, it can produce a summary report of the processed data.\n\n    Parameters:\n        kcat_file_path (str): Path to the input kcat data file.\n        output_path (str): Path to save the generated CataPro input CSV file.\n        limit_matching_score (int): Threshold for filtering entries based on matching score.\n        report (bool, optional): Whether to generate a report using the retrieved data (default: True). \n    \"\"\"\n    # Add a deduplication filter to the logger\n    logging.getLogger().addFilter(DedupFilter())\n\n    # Read the kcat file\n    kcat_df = pd.read_csv(kcat_file_path, sep='\\t')\n\n    # Subset rows with no values or matching score above the limit\n    kcat_df = kcat_df[(kcat_df['matching_score'] &gt;= limit_matching_score) | (kcat_df['matching_score'].isnull())]\n    # Drop rows with no UniProt ID or no substrates_kegg\n    before_duplicates_filter = len(kcat_df) - 1 \n    kcat_df = kcat_df[kcat_df['uniprot_model'].notnull() &amp; kcat_df['substrates_kegg'].notnull()]\n    nb_missing_enzymes = before_duplicates_filter - len(kcat_df)\n\n    # Generate CataPro input file\n    catapro_input_df, substrates_to_smiles_df, report_statistics = create_catapro_input_file(kcat_df)\n\n    # Save the CataPro input file and substrates to SMILES mapping\n    catapro_input_df.to_csv(output_path, sep=',', index=True)\n    substrates_to_smiles_df.to_csv(output_path.replace('.csv', '_substrates_to_smiles.tsv'), sep='\\t', index=False)\n    logging.info(f\"Output saved to '{output_path}'\")\n\n    # Add statistics \n    report_statistics[\"missing_enzymes\"] = nb_missing_enzymes\n\n    if report:\n        report_prediction_input(catapro_input_df, report_statistics)\n</code></pre>"},{"location":"reference/#wildkcat.processing.predict_kcat.run_prediction_part2","title":"<code>wildkcat.processing.predict_kcat.run_prediction_part2(kcat_file_path, catapro_predictions_path, substrates_to_smiles_path, output_path, limit_matching_score)</code>","text":"<p>Runs the second part of the kcat prediction pipeline by integrating Catapro predictions, mapping substrates to SMILES, formatting the output, and optionally generating a report.</p> <p>Parameters:</p> Name Type Description Default <code>kcat_file_path</code> <code>str</code> <p>Path to the input kcat TSV file.</p> required <code>catapro_predictions_path</code> <code>str</code> <p>Path to the Catapro predictions CSV file.</p> required <code>substrates_to_smiles_path</code> <code>str</code> <p>Path to the TSV file mapping substrates to SMILES.</p> required <code>output_path</code> <code>str</code> <p>Path to save the formatted output TSV file.</p> required <code>limit_matching_score</code> <code>float</code> <p>Threshold for taking predictions over retrieved values.</p> required Source code in <code>wildkcat/processing/predict_kcat.py</code> <pre><code>def run_prediction_part2(kcat_file_path: str, \n                         catapro_predictions_path: str, \n                         substrates_to_smiles_path: str, \n                         output_path: str,\n                         limit_matching_score: int) -&gt; None:\n    \"\"\"\n    Runs the second part of the kcat prediction pipeline by integrating Catapro predictions,\n    mapping substrates to SMILES, formatting the output, and optionally generating a report.\n\n    Parameters:\n        kcat_file_path (str): Path to the input kcat TSV file.\n        catapro_predictions_path (str): Path to the Catapro predictions CSV file.\n        substrates_to_smiles_path (str): Path to the TSV file mapping substrates to SMILES.\n        output_path (str): Path to save the formatted output TSV file.\n        limit_matching_score (float): Threshold for taking predictions over retrieved values.\n    \"\"\" \n    kcat_df = pd.read_csv(kcat_file_path, sep='\\t')\n    substrates_to_smiles = pd.read_csv(substrates_to_smiles_path, sep='\\t')\n    catapro_predictions_df = pd.read_csv(catapro_predictions_path, sep=',')\n    kcat_df = integrate_catapro_predictions(kcat_df, \n                                            substrates_to_smiles,\n                                            catapro_predictions_df\n                                            )\n\n    # Save the output as a TSV file\n    kcat_df = format_output(kcat_df, limit_matching_score)\n    kcat_df.to_csv(output_path, sep='\\t', index=False)\n    logging.info(f\"Output saved to '{output_path}'\")\n</code></pre>"},{"location":"reference/#summary-report","title":"Summary report","text":""},{"location":"reference/#wildkcat.processing.summary.generate_summary_report","title":"<code>wildkcat.processing.summary.generate_summary_report(model_path, kcat_file_path)</code>","text":"<p>Generate a HTML report summarizing the kcat extraction, retrieval and prediction for a given model. </p> <p>Parameters:</p> Name Type Description Default <code>model_path</code> <code>str</code> <p>Path to the metabolic model file (JSON, MATLAB, or SBML format).</p> required <code>kcat_file_path</code> <code>str</code> <p>Path to the final kcat TSV file.</p> required Source code in <code>wildkcat/processing/summary.py</code> <pre><code>def generate_summary_report(model_path: str,\n                            kcat_file_path: str) -&gt; None:\n    \"\"\"\n    Generate a HTML report summarizing the kcat extraction, retrieval and prediction for a given model. \n\n    Parameters:\n        model_path (str): Path to the metabolic model file (JSON, MATLAB, or SBML format).\n        kcat_file_path (str): Path to the final kcat TSV file.\n    \"\"\"\n    kcat_df = pd.read_csv(kcat_file_path, sep='\\t')\n    model = read_model(model_path)\n    report_final(model, kcat_df)\n</code></pre>"},{"location":"reference/#matching-process-and-scoring","title":"Matching process and scoring","text":"<p>The matching process is designed to select the most appropriate kcat value when multiple candidates are available. Each candidate is first assigned a score based on several criteria, such as:  </p> <ul> <li>kcat specific criteria:<ul> <li>Substrate</li> <li>Catalytic enzyme(s)</li> </ul> </li> <li>General criteria:<ul> <li>Organism</li> <li>Temperature</li> <li>pH</li> </ul> </li> </ul> <p>If two or more candidates receive the same score, tie-breaking rules are applied in the following order:  </p> <ol> <li>Enzyme sequence identity \u2013 the value associated with the most similar protein sequence is preferred.  </li> <li>Organism proximity \u2013 preference is given to kcat values measured in organisms closest to the target species.  </li> <li>Minimal kcat value \u2013 if ambiguity remains, the smallest kcat value is chosen. </li> </ol> <p>heading_level: 3</p>"},{"location":"reference/#wildkcat.utils.matching","title":"<code>wildkcat.utils.matching</code>","text":""},{"location":"reference/#wildkcat.utils.matching.check_catalytic_enzyme","title":"<code>check_catalytic_enzyme(candidate, kcat_dict)</code>","text":"<p>Checks whether the enzyme in a candidate entry matches the model's enzyme. Identifies the catalytic enzyme using UniProt API.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def check_catalytic_enzyme(candidate, kcat_dict): \n    \"\"\"\n    Checks whether the enzyme in a candidate entry matches the model's enzyme.\n    Identifies the catalytic enzyme using UniProt API.\n    \"\"\"\n    if pd.notna(kcat_dict['catalytic_enzyme']):\n        catalytic_enzymes = str(kcat_dict['catalytic_enzyme']).split(\";\")\n        if candidate[\"UniProtKB_AC\"] in catalytic_enzymes:\n            return 0\n    return 2\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.check_organism","title":"<code>check_organism(candidate, general_criteria)</code>","text":"<p>Checks whether the organism in a candidate entry matches the expected organism.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def check_organism(candidate, general_criteria): \n    \"\"\"\n    Checks whether the organism in a candidate entry matches the expected organism.\n    \"\"\"\n    if candidate[\"Organism\"] == general_criteria[\"Organism\"]:\n        return 0\n    return 2\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.check_pH","title":"<code>check_pH(candidate, general_criteria)</code>","text":"<p>Checks whether the pH in a candidate entry matches the expected pH.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def check_pH(candidate, general_criteria):\n    \"\"\"\n    Checks whether the pH in a candidate entry matches the expected pH.\n    \"\"\"\n    ph_min, ph_max = general_criteria[\"pH\"]\n    candidate_ph = candidate.get(\"pH\", None)\n    if ph_min &lt;= candidate_ph &lt;= ph_max:\n        return 0\n    elif pd.isna(candidate_ph):\n        return 1\n    else:  # Out of range\n        return 2\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.check_substrate","title":"<code>check_substrate(entry, kcat_dict=None, candidate=None)</code>","text":"<p>Checks whether the substrate in a candidate entry matches the model's substrates.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def check_substrate(entry, kcat_dict=None, candidate=None):\n    \"\"\"\n    Checks whether the substrate in a candidate entry matches the model's substrates.\n    \"\"\"\n    api = entry.get(\"db\", candidate.get(\"db\") if candidate else None)\n\n    # Normalisation des champs\n    entry_subs = entry.get(\"Substrate\", \"\")\n    entry_prods = entry.get(\"Product\", \"\")\n    entry_kegg = entry.get(\"KeggReactionID\")\n\n    cand_subs = candidate.get(\"Substrate\", \"\") if candidate else \"\"\n    cand_prods = candidate.get(\"Product\", \"\") if candidate else \"\"\n    cand_kegg = candidate.get(\"KeggReactionID\") if candidate else \"\"\n\n    model_subs = (kcat_dict or {}).get(\"substrates_name\", \"\")\n    model_prods = (kcat_dict or {}).get(\"products_name\", \"\")\n    model_kegg = (kcat_dict or {}).get(\"KEGG_rxn_id\")\n\n    # --- logique identique \u00e0 avant ---\n    if api == \"sabio_rk\":\n\n        entry_kegg = None if pd.isna(entry_kegg) else entry_kegg\n        model_kegg = None if pd.isna(model_kegg) else model_kegg\n        cand_kegg  = None if pd.isna(cand_kegg) else cand_kegg\n\n        if model_kegg and entry_kegg and _norm_name(model_kegg) == _norm_name(entry_kegg):\n            if _any_intersection(entry_subs, model_subs) or _any_intersection(entry_prods, model_prods):\n                return 0\n        if cand_kegg and entry_kegg and _norm_name(cand_kegg) == _norm_name(entry_kegg):\n            if _any_intersection(entry_subs, cand_subs) or _any_intersection(entry_prods, cand_prods):\n                return 0\n        base_subs = model_subs or cand_subs\n        if _any_intersection(entry_subs, base_subs):\n            return 0\n        return 3\n\n    elif api == \"brenda\":\n        base_subs = model_subs or cand_subs\n        if _any_intersection(entry_subs, base_subs):\n            return 0\n        return 3\n\n    return 3\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.check_temperature","title":"<code>check_temperature(candidate, general_criteria, api_output, min_r2=0.8, expected_range=(50000, 150000))</code>","text":"<p>Checks whether the temperature in a candidate entry matches the expected temperature. If the temperature is within the specified range is not met, verify if the Arrhenius equation can be applied.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def check_temperature(candidate, general_criteria, api_output, min_r2=0.8, expected_range=(50000, 150000)): \n    \"\"\"\n    Checks whether the temperature in a candidate entry matches the expected temperature.\n    If the temperature is within the specified range is not met, verify if the Arrhenius equation can be applied.\n    \"\"\"\n\n    temp_min, temp_max = general_criteria[\"Temperature\"]\n    candidate_temp = candidate.get(\"Temperature\")\n\n    if temp_min &lt;= candidate_temp &lt;= temp_max:\n        return 0, False\n\n    # Try to find a correct the kcat value using the Arrhenius equation\n    ph_min, ph_max = general_criteria[\"pH\"]\n\n    # Base filters\n    filters = (\n        api_output[\"pH\"].between(ph_min, ph_max)\n        &amp; (api_output[\"UniProtKB_AC\"] == candidate[\"UniProtKB_AC\"])\n        &amp; api_output[\"Temperature\"].notna()\n        &amp; api_output[\"value\"].notna()\n    )\n\n    valid_idx = api_output.apply(\n        lambda row: check_substrate(row.to_dict(), None, candidate) == 0,\n        axis=1\n        )\n\n    filters = filters &amp; valid_idx\n\n    temps_dispo = api_output.loc[filters, \"Temperature\"].nunique()\n    api_filtered = api_output.loc[filters, [\"Temperature\", \"value\"]].copy()\n\n    # Convert temperatures to Kelvin\n    api_filtered[\"Temperature\"] = api_filtered[\"Temperature\"] + 273.15\n\n    if temps_dispo &gt;= 2:\n        ea, r2 = calculate_ea(api_filtered)\n        if r2 &gt;= min_r2 and ea &gt; 0:\n            if not (expected_range[0] &lt;= ea &lt;= expected_range[1]):\n                logger.warning(f\"{candidate.get('ECNumber')}: Estimated Ea ({ea:.0f} J/mol) is outside the expected range {expected_range} J/mol.\")\n            # Go Arrhenius\n            return 0, True\n\n    if pd.isna(candidate_temp):\n        return 1, False\n\n    else:\n        return 2, False\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.check_variant","title":"<code>check_variant(candidate)</code>","text":"<p>Checks whether the enzyme variant in a candidate entry is wildtype or unknown.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def check_variant(candidate):\n    \"\"\"\n    Checks whether the enzyme variant in a candidate entry is wildtype or unknown.\n    \"\"\"\n    if candidate[\"EnzymeVariant\"] == \"wildtype\":\n        return 0\n    else:  # Unknown\n        return 1\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.compute_score","title":"<code>compute_score(kcat_dict, candidate, general_criteria, api_output)</code>","text":"<p>Compute a score for the candidate based on the Kcat dictionary and general criteria.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def compute_score(kcat_dict, candidate, general_criteria, api_output):\n    \"\"\"\n    Compute a score for the candidate based on the Kcat dictionary and general criteria.\n    \"\"\"\n    score = 0\n    # Check catalytic enzyme\n    score += check_catalytic_enzyme(candidate, kcat_dict)\n    # Check organism\n    if score != 0: \n        score += check_organism(candidate, general_criteria)\n    # Check variant\n    score += check_variant(candidate) \n    # Check pH\n    score += check_pH(candidate, general_criteria)\n    # Check substrate \n    score += check_substrate(candidate, kcat_dict)\n    # Check temperature \n    temperature_penalty, arrhenius = check_temperature(candidate, general_criteria, api_output) \n    score += temperature_penalty\n    return score, arrhenius\n</code></pre>"},{"location":"reference/#wildkcat.utils.matching.find_best_match","title":"<code>find_best_match(kcat_dict, api_output, general_criteria)</code>","text":"Finds the best matching enzyme entry from the provided API output based on <ul> <li>Kcat specific criteria: <ul> <li>Substrate </li> <li>Catalytic enzyme(s)</li> </ul> </li> <li>General criteria : <ul> <li>Organism</li> <li>Temperature</li> <li>pH</li> </ul> </li> </ul> <p>This function filters out mutant enzyme variants, orders the remaining entries based on enzyme and organism similarity, and iteratively computes a score for each candidate to identify the best match. If a candidate requires an Arrhenius adjustment, the kcat value is recalculated accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>kcat_dict</code> <code>dict</code> <p>Dictionary containing enzyme information.</p> required <code>api_output</code> <code>DataFrame</code> <p>DataFrame containing kcat entries and metadata from an API.</p> required <code>general_criteria</code> <code>dict</code> <p>Dictionary specifying matching criteria.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[float, Optional[Dict[str, Any]]]</code> <p>best_score (float): The lowest score found, representing the best match. best_candidate (dict or None): Dictionary of the best matching candidate's data, or None if no match is found.</p> Source code in <code>wildkcat/utils/matching.py</code> <pre><code>def find_best_match(kcat_dict, api_output, general_criteria) -&gt; Tuple[float, Optional[Dict[str, Any]]]:\n    \"\"\"\n    Finds the best matching enzyme entry from the provided API output based on: \n        - Kcat specific criteria: \n            * Substrate \n            * Catalytic enzyme(s)\n        - General criteria : \n            * Organism\n            * Temperature\n            * pH\n\n    This function filters out mutant enzyme variants, orders the remaining entries based on enzyme and organism similarity,\n    and iteratively computes a score for each candidate to identify the best match. If a candidate requires an Arrhenius\n    adjustment, the kcat value is recalculated accordingly.\n\n    Parameters:\n        kcat_dict (dict): Dictionary containing enzyme information.\n        api_output (pd.DataFrame): DataFrame containing kcat entries and metadata from an API.\n        general_criteria (dict): Dictionary specifying matching criteria.\n\n    Returns:\n        tuple:\n            best_score (float): The lowest score found, representing the best match.\n            best_candidate (dict or None): Dictionary of the best matching candidate's data, or None if no match is found.\n    \"\"\"\n\n    # 1. Remove mutant enzymes\n    api_output = api_output[api_output[\"EnzymeVariant\"].isin(['wildtype', None])]\n    if api_output.empty:\n        return 14, None\n\n    # 2. Compute score and adjust kcat if needed\n    scores = []\n    adjusted_kcats, adjusted_temps = [], []\n\n    for _, row in api_output.iterrows():\n        candidate_dict = row.to_dict()\n        score, arrhenius = compute_score(kcat_dict, candidate_dict, general_criteria, api_output)\n        if arrhenius:\n            kcat = arrhenius_equation(candidate_dict, api_output, general_criteria)\n            candidate_dict['value'] = kcat\n            candidate_dict['Temperature'] = np.mean(general_criteria[\"Temperature\"])\n        scores.append(score)\n        adjusted_kcats.append(candidate_dict.get('value', row['value']))\n        adjusted_temps.append(candidate_dict.get('Temperature', row['Temperature']))\n\n    api_output = api_output.copy()\n    api_output['score'] = scores\n    api_output['adj_kcat'] = adjusted_kcats\n    api_output['adj_temp'] = adjusted_temps\n\n    api_output[\"score\"] = pd.to_numeric(api_output[\"score\"], errors=\"coerce\").fillna(13)\n    api_output[\"adj_kcat\"] = pd.to_numeric(api_output[\"adj_kcat\"], errors=\"coerce\")\n\n    # Initialize columns for tie-breaking\n    api_output['id_perc'] = -1\n    api_output['organism_score'] = np.inf\n\n    # 3. Keep only best-score candidates\n    min_score = api_output['score'].min()\n    tied = api_output[api_output['score'] == min_score]\n\n    # 4. Tie-breaking\n    if len(tied) &gt; 1:\n        # Tie-break with enzyme identity\n        tied = closest_enz(kcat_dict, tied)\n        if not tied['id_perc'].isna().all():\n            max_id = tied['id_perc'].max()\n            tied = tied[tied['id_perc'] == max_id]\n\n    if len(tied) &gt; 1:\n        # Tie-break with taxonomy\n        tied = closest_taxonomy(general_criteria, tied)\n        if not tied['organism_score'].isna().all():\n            min_tax = tied['organism_score'].min()\n            tied = tied[tied['organism_score'] == min_tax]\n\n    if len(tied) &gt; 1:\n        # Tie-break with lowest kcat\n        min_kcat = tied['adj_kcat'].min()\n        tied = tied[tied['adj_kcat'] == min_kcat]\n\n    # 5. Select best candidate\n    best_candidate = tied.iloc[0].to_dict()\n    best_candidate['catalytic_enzyme'] = kcat_dict.get('catalytic_enzyme')\n    best_score = best_candidate['score']\n\n    return best_score, best_candidate\n</code></pre>"}]}